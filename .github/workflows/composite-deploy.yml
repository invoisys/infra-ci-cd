# Composite Deploy Workflow
# Deploy Docker image to ECS Fargate

name: Deploy

on:
  workflow_call:
    inputs:
      # Required inputs
      image_uri:
        description: 'Full image URI in ECR'
        required: true
        type: string
      ecs_service:
        description: 'ECS service name'
        required: true
        type: string
      environment:
        description: 'Environment (dev|qa|sbx|prd)'
        required: true
        type: string
      service_type:
        description: 'Service type: api or worker'
        required: true
        type: string
      
      # AWS & ECS Configuration
      aws_region:
        description: 'AWS region'
        required: false
        type: string
        default: 'us-east-1'
      ecs_cluster:
        description: 'ECS cluster name'
        required: false
        type: string
        default: ''
      ecs_task_execution_role_arn:
        description: 'Task execution role ARN'
        required: false
        type: string
        default: ''
      ecs_task_role_arn:
        description: 'Task role ARN'
        required: false
        type: string
        default: ''
      
      # Task Definition
      task_cpu:
        description: 'CPU units (256, 512, 1024, 2048, 4096)'
        required: false
        type: string
        default: '256'
      task_memory:
        description: 'Memory in MB'
        required: false
        type: string
        default: '512'
      container_name:
        description: 'Container name'
        required: false
        type: string
        default: 'app'
      container_port:
        description: 'Container port'
        required: false
        type: string
        default: '80'
      container_environment:
        description: 'JSON array of environment variables'
        required: false
        type: string
        default: ''
      container_secrets:
        description: 'JSON array of secrets'
        required: false
        type: string
        default: ''
      
      # Runtime Platform
      runtime_cpu_architecture:
        description: 'CPU architecture (X86_64, ARM64)'
        required: false
        type: string
        default: ''
      runtime_os_family:
        description: 'OS family (LINUX, WINDOWS_SERVER_2019_CORE)'
        required: false
        type: string
        default: ''
      
      # Logging
      awslogs_mode:
        description: 'awslogs mode (non-blocking, blocking)'
        required: false
        type: string
        default: ''
      awslogs_create_group:
        description: 'Create log group if not exists'
        required: false
        type: string
        default: ''
      awslogs_max_buffer_size:
        description: 'Max buffer size'
        required: false
        type: string
        default: ''
      port_mapping_app_protocol:
        description: 'App protocol for port mapping'
        required: false
        type: string
        default: ''
      
      # Network Configuration
      subnet_ids:
        description: 'Subnet IDs (comma-separated)'
        required: false
        type: string
        default: ''
      security_group_ids:
        description: 'Security group IDs (comma-separated)'
        required: false
        type: string
        default: ''
      assign_public_ip:
        description: 'Assign public IP (ENABLED/DISABLED)'
        required: false
        type: string
        default: 'DISABLED'
      
      # Service Configuration
      desired_count:
        description: 'Desired task count'
        required: false
        type: string
        default: '1'
      
      # Load Balancer (API only)
      create_target_group_and_listener:
        description: 'Create/use target group and listener'
        required: false
        type: boolean
        default: false
      load_balancer_arn:
        description: 'ALB ARN'
        required: false
        type: string
        default: ''
      load_balancer_name:
        description: 'ALB name'
        required: false
        type: string
        default: ''
      listener_port:
        description: 'Listener port'
        required: false
        type: string
        default: '80'
      target_group_name:
        description: 'Target group name'
        required: false
        type: string
        default: ''
      target_group_port:
        description: 'Target group port'
        required: false
        type: string
        default: '80'
      target_group_protocol:
        description: 'Target group protocol'
        required: false
        type: string
        default: 'HTTP'
      target_group_health_check_path:
        description: 'Health check path'
        required: false
        type: string
        default: '/'
      target_group_health_check_protocol:
        description: 'Health check protocol'
        required: false
        type: string
        default: 'HTTP'
      target_group_deregistration_delay_seconds:
        description: 'Deregistration delay'
        required: false
        type: string
        default: '300'
      listener_rule_path_pattern:
        description: 'Listener rule path pattern'
        required: false
        type: string
        default: ''
      listener_rule_host_header:
        description: 'Listener rule host header'
        required: false
        type: string
        default: ''
      listener_rule_priority:
        description: 'Listener rule priority'
        required: false
        type: string
        default: ''
      
      # Advanced Service Options
      enable_zone_rebalancing:
        description: 'Enable zone rebalancing'
        required: false
        type: boolean
        default: false
      health_check_grace_period_seconds:
        description: 'Health check grace period'
        required: false
        type: string
        default: ''
      deployment_circuit_breaker_enable:
        description: 'Enable deployment circuit breaker'
        required: false
        type: boolean
        default: false
      deployment_circuit_breaker_rollback:
        description: 'Auto rollback on circuit breaker'
        required: false
        type: boolean
        default: false
      capacity_provider_strategy:
        description: 'Capacity provider strategy'
        required: false
        type: string
        default: ''
      platform_version:
        description: 'Fargate platform version'
        required: false
        type: string
        default: ''
      enable_execute_command:
        description: 'Enable ECS Exec'
        required: false
        type: boolean
        default: false
      deployment_minimum_healthy_percent:
        description: 'Min healthy percent during deploy'
        required: false
        type: string
        default: ''
      deployment_maximum_percent:
        description: 'Max percent during deploy'
        required: false
        type: string
        default: ''
        
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
        
    outputs:
      service_arn:
        description: 'ECS service ARN'
        value: ${{ jobs.deploy.outputs.service_arn }}
      task_definition_arn:
        description: 'Registered task definition ARN'
        value: ${{ jobs.deploy.outputs.task_definition_arn }}
      deploy_metadata_artifact:
        description: 'Deploy metadata artifact name'
        value: ${{ jobs.deploy.outputs.deploy_metadata_artifact }}

jobs:
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      service_arn: ${{ steps.finalize.outputs.service_arn }}
      task_definition_arn: ${{ steps.task-def.outputs.task_definition_arn }}
      deploy_metadata_artifact: ${{ steps.metadata.outputs.artifact_name }}

    steps:
      - name: Validate inputs
        run: |
          # Validate environment
          case "${{ inputs.environment }}" in
            dev|qa|sbx|prd) echo "âœ… Environment: ${{ inputs.environment }}" ;;
            *) echo "âŒ Invalid environment: ${{ inputs.environment }}" && exit 1 ;;
          esac
          
          # Validate service_type
          case "${{ inputs.service_type }}" in
            api|worker) echo "âœ… Service type: ${{ inputs.service_type }}" ;;
            *) echo "âŒ Invalid service_type: ${{ inputs.service_type }}" && exit 1 ;;
          esac
          
          # Validate required inputs
          [ -z "${{ inputs.image_uri }}" ] && echo "âŒ image_uri is required" && exit 1
          [ -z "${{ inputs.ecs_service }}" ] && echo "âŒ ecs_service is required" && exit 1
          echo "âœ… All required inputs provided"

      - name: Validate secrets
        run: |
          [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && echo "âŒ AWS_ACCESS_KEY_ID not provided" && exit 1
          [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ] && echo "âŒ AWS_SECRET_ACCESS_KEY not provided" && exit 1
          echo "âœ… AWS credentials provided"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Register Task Definition
        id: task-def
        env:
          CLUSTER: ${{ inputs.ecs_cluster || secrets.ECS_CLUSTER }}
          SERVICE: ${{ inputs.ecs_service }}
          FULL_IMAGE: ${{ inputs.image_uri }}
          TASK_EXEC_ROLE: ${{ inputs.ecs_task_execution_role_arn || secrets.ECS_TASK_EXECUTION_ROLE_ARN }}
          TASK_ROLE: ${{ inputs.ecs_task_role_arn }}
          CONTAINER_NAME: ${{ inputs.container_name || 'app' }}
          CONTAINER_PORT: ${{ inputs.container_port || '80' }}
          AWS_REGION: ${{ inputs.aws_region }}
          TASK_CPU: ${{ inputs.task_cpu || '256' }}
          TASK_MEMORY: ${{ inputs.task_memory || '512' }}
          CONTAINER_ENVIRONMENT: ${{ inputs.container_environment }}
          CONTAINER_SECRETS: ${{ inputs.container_secrets }}
          RUNTIME_CPU: ${{ inputs.runtime_cpu_architecture }}
          RUNTIME_OS: ${{ inputs.runtime_os_family }}
          AWSLOGS_MODE: ${{ inputs.awslogs_mode }}
          AWSLOGS_CREATE_GROUP: ${{ inputs.awslogs_create_group }}
          AWSLOGS_MAX_BUFFER: ${{ inputs.awslogs_max_buffer_size }}
          PORT_APP_PROTOCOL: ${{ inputs.port_mapping_app_protocol }}
        run: |
          set -e
          echo "ðŸ–¼ï¸ Image: $FULL_IMAGE"
          
          # Check if service exists
          EXISTING=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query 'services[?status==`ACTIVE`]' --output json)
          SERVICE_EXISTS=$(echo "$EXISTING" | jq 'length > 0')
          echo "service_exists=${SERVICE_EXISTS}" >> $GITHUB_OUTPUT
          
          if [ "$SERVICE_EXISTS" = "true" ]; then
            echo "ðŸ”„ Service exists: reusing task definition..."
            CURRENT_TASK_ARN=$(echo "$EXISTING" | jq -r '.[0].taskDefinition')
            TASK_DEF_JSON=$(aws ecs describe-task-definition --task-definition "$CURRENT_TASK_ARN" --query 'taskDefinition' --output json)
            TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq 'del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities,.registeredAt,.registeredBy)')
            TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --arg img "$FULL_IMAGE" '.containerDefinitions[0].image = $img')
            
            # Merge idempotente de environment (por name): input vazio preserva existente
            if [ -n "$CONTAINER_ENVIRONMENT" ] && [ "$CONTAINER_ENVIRONMENT" != "[]" ]; then
              echo "$CONTAINER_ENVIRONMENT" | jq -e . >/dev/null 2>&1 && \
              TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --argjson env "$CONTAINER_ENVIRONMENT" \
                '.containerDefinitions[0].environment = ([.containerDefinitions[0].environment // [] | .[], $env[]] | group_by(.name) | map(last))')
            fi
            
            # Merge idempotente de secrets (por name): input vazio preserva existente
            if [ -n "$CONTAINER_SECRETS" ] && [ "$CONTAINER_SECRETS" != "[]" ]; then
              echo "$CONTAINER_SECRETS" | jq -e . >/dev/null 2>&1 && \
              TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --argjson sec "$CONTAINER_SECRETS" \
                '.containerDefinitions[0].secrets = ([.containerDefinitions[0].secrets // [] | .[], $sec[]] | group_by(.name) | map(last))')
            fi
          else
            echo "ðŸ†• Service does not exist: creating task definition from scratch..."
            [ -z "$TASK_EXEC_ROLE" ] && echo "âŒ Execution role is required for new services" && exit 1
            
            PORT_NUM=$(echo "$CONTAINER_PORT" | grep -E '^[0-9]+$' || echo "80")
            LOG_GROUP="/ecs/${SERVICE}"
            
            # Port mapping
            PORT_MAPPING=$(jq -n --arg name "${CONTAINER_NAME}-${PORT_NUM}-tcp" --argjson port "$PORT_NUM" \
              '{name:$name,containerPort:$port,hostPort:$port,protocol:"tcp"}')
            [ -n "$PORT_APP_PROTOCOL" ] && PORT_MAPPING=$(echo "$PORT_MAPPING" | jq --arg p "$PORT_APP_PROTOCOL" '.+{appProtocol:$p}')
            
            # Log options
            LOG_OPTS=$(jq -n --arg lg "$LOG_GROUP" --arg r "$AWS_REGION" '{"awslogs-group":$lg,"awslogs-region":$r,"awslogs-stream-prefix":"ecs"}')
            [ -n "$AWSLOGS_MODE" ] && LOG_OPTS=$(echo "$LOG_OPTS" | jq --arg m "$AWSLOGS_MODE" '.+{mode:$m}')
            [ -n "$AWSLOGS_CREATE_GROUP" ] && LOG_OPTS=$(echo "$LOG_OPTS" | jq --arg c "$AWSLOGS_CREATE_GROUP" '.+{"awslogs-create-group":$c}')
            [ -n "$AWSLOGS_MAX_BUFFER" ] && LOG_OPTS=$(echo "$LOG_OPTS" | jq --arg b "$AWSLOGS_MAX_BUFFER" '.+{"max-buffer-size":$b}')
            
            # Container definition
            CONTAINER_DEF=$(jq -n --arg n "$CONTAINER_NAME" --arg img "$FULL_IMAGE" --argjson pm "$PORT_MAPPING" --argjson lo "$LOG_OPTS" \
              '{name:$n,image:$img,portMappings:[$pm],logConfiguration:{logDriver:"awslogs",options:$lo},essential:true}')
            
            [ -n "$CONTAINER_ENVIRONMENT" ] && [ "$CONTAINER_ENVIRONMENT" != "[]" ] && \
              echo "$CONTAINER_ENVIRONMENT" | jq -e . >/dev/null 2>&1 && \
              CONTAINER_DEF=$(echo "$CONTAINER_DEF" | jq --argjson e "$CONTAINER_ENVIRONMENT" '.+{environment:$e}')
            
            [ -n "$CONTAINER_SECRETS" ] && [ "$CONTAINER_SECRETS" != "[]" ] && \
              echo "$CONTAINER_SECRETS" | jq -e . >/dev/null 2>&1 && \
              CONTAINER_DEF=$(echo "$CONTAINER_DEF" | jq --argjson s "$CONTAINER_SECRETS" '.+{secrets:$s}')
            
            # Task definition
            TASK_DEF_JSON=$(jq -n --arg f "$SERVICE" --arg er "$TASK_EXEC_ROLE" --arg cpu "$TASK_CPU" --arg mem "$TASK_MEMORY" --argjson c "$CONTAINER_DEF" \
              '{family:$f,networkMode:"awsvpc",requiresCompatibilities:["FARGATE"],cpu:$cpu,memory:$mem,executionRoleArn:$er,containerDefinitions:[$c]}')
            [ -n "$TASK_ROLE" ] && TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --arg tr "$TASK_ROLE" '.+{taskRoleArn:$tr}')
            
            # Runtime platform
            if [ -n "$RUNTIME_CPU" ] || [ -n "$RUNTIME_OS" ]; then
              RT=$(jq -n '{}')
              [ -n "$RUNTIME_CPU" ] && RT=$(echo "$RT" | jq --arg c "$RUNTIME_CPU" '.+{cpuArchitecture:$c}')
              [ -n "$RUNTIME_OS" ] && RT=$(echo "$RT" | jq --arg o "$RUNTIME_OS" '.+{operatingSystemFamily:$o}')
              TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --argjson rt "$RT" '.+{runtimePlatform:$rt}')
            fi
          fi
          
          # Register task definition
          TASK_DEF_FILE=$(mktemp)
          echo "$TASK_DEF_JSON" > "$TASK_DEF_FILE"
          NEW_TASK_ARN=$(aws ecs register-task-definition --cli-input-json "file://${TASK_DEF_FILE}" --query 'taskDefinition.taskDefinitionArn' --output text)
          rm -f "$TASK_DEF_FILE"
          
          echo "task_definition_arn=${NEW_TASK_ARN}" >> $GITHUB_OUTPUT
          echo "âœ… Task definition: $NEW_TASK_ARN"

      - name: Configure Target Group
        id: target-group
        if: inputs.service_type == 'api' && inputs.create_target_group_and_listener
        env:
          SUBNET_IDS: ${{ inputs.subnet_ids }}
          TG_NAME: ${{ inputs.target_group_name }}
          TG_PORT: ${{ inputs.target_group_port }}
          TG_PROTOCOL: ${{ inputs.target_group_protocol }}
          TG_HEALTH_CHECK_PATH: ${{ inputs.target_group_health_check_path }}
          TG_HEALTH_CHECK_PROTOCOL: ${{ inputs.target_group_health_check_protocol }}
          TG_DEREGISTRATION_DELAY: ${{ inputs.target_group_deregistration_delay_seconds }}
          LOAD_BALANCER_ARN: ${{ inputs.load_balancer_arn }}
          LOAD_BALANCER_NAME: ${{ inputs.load_balancer_name }}
        run: |
          set -e
          [ -z "$TG_NAME" ] && echo "âŒ target_group_name is required for API" && exit 1
          
          # Resolve LB ARN
          LB_ARN="$LOAD_BALANCER_ARN"
          if [ -z "$LB_ARN" ] && [ -n "$LOAD_BALANCER_NAME" ]; then
            LB_ARN=$(aws elbv2 describe-load-balancers --names "$LOAD_BALANCER_NAME" --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || true)
            [ -z "$LB_ARN" ] || [ "$LB_ARN" = "None" ] && echo "âŒ LB '$LOAD_BALANCER_NAME' not found" && exit 1
          fi
          [ -z "$LB_ARN" ] && echo "âŒ Provide load_balancer_arn or load_balancer_name" && exit 1
          echo "load_balancer_arn=${LB_ARN}" >> $GITHUB_OUTPUT
          
          # Get VPC from subnet
          FIRST_SUBNET=$(echo "$SUBNET_IDS" | cut -d',' -f1)
          VPC_ID=$(aws ec2 describe-subnets --subnet-ids "$FIRST_SUBNET" --query 'Subnets[0].VpcId' --output text)
          
          # Check existing target group
          EXISTING_TG=$(aws elbv2 describe-target-groups --names "$TG_NAME" --query 'TargetGroups[0]' --output json 2>/dev/null || echo "null")
          
          if [ "$EXISTING_TG" != "null" ]; then
            TG_ARN=$(echo "$EXISTING_TG" | jq -r '.TargetGroupArn')
            echo "âœ… Existing TG: $TG_ARN"
          else
            echo "ðŸ“ Creating TG: $TG_NAME"
            TG_ARN=$(aws elbv2 create-target-group \
              --name "$TG_NAME" --protocol "${TG_PROTOCOL:-HTTP}" --port "${TG_PORT:-80}" \
              --vpc-id "$VPC_ID" --target-type ip \
              --health-check-path "${TG_HEALTH_CHECK_PATH:-/}" --health-check-protocol "${TG_HEALTH_CHECK_PROTOCOL:-HTTP}" \
              --matcher "HttpCode=200-499" \
              --query 'TargetGroups[0].TargetGroupArn' --output text)
            echo "âœ… Created TG: $TG_ARN"
            
            [ -n "$TG_DEREGISTRATION_DELAY" ] && [ "$TG_DEREGISTRATION_DELAY" != "300" ] && \
              aws elbv2 modify-target-group-attributes --target-group-arn "$TG_ARN" \
                --attributes "Key=deregistration_delay.timeout_seconds,Value=$TG_DEREGISTRATION_DELAY"
          fi
          echo "target_group_arn=${TG_ARN}" >> $GITHUB_OUTPUT

      - name: Configure Listener Rule
        id: listener-rule
        if: inputs.service_type == 'api' && inputs.create_target_group_and_listener
        env:
          SERVICE: ${{ inputs.ecs_service }}
          LOAD_BALANCER_ARN: ${{ steps.target-group.outputs.load_balancer_arn }}
          TARGET_GROUP_ARN: ${{ steps.target-group.outputs.target_group_arn }}
          LISTENER_PORT: ${{ inputs.listener_port }}
          LISTENER_RULE_PATH: ${{ inputs.listener_rule_path_pattern }}
          LISTENER_RULE_HOST: ${{ inputs.listener_rule_host_header }}
          LISTENER_RULE_PRIORITY: ${{ inputs.listener_rule_priority }}
        run: |
          set -e
          PORT="${LISTENER_PORT:-80}"
          
          # Get existing listener
          LISTENER_JSON=$(aws elbv2 describe-listeners --load-balancer-arn "$LOAD_BALANCER_ARN" \
            --query "Listeners[?Port==\`$PORT\`]" --output json | jq '.[0]')
          [ "$LISTENER_JSON" = "null" ] && echo "âŒ Listener on port $PORT does not exist" && exit 1
          
          LISTENER_ARN=$(echo "$LISTENER_JSON" | jq -r '.ListenerArn')
          echo "âœ… Listener: $LISTENER_ARN"
          echo "listener_arn=${LISTENER_ARN}" >> $GITHUB_OUTPUT
          
          # Check existing rule for this target group
          RULES=$(aws elbv2 describe-rules --listener-arn "$LISTENER_ARN" --output json)
          TG_RULE=$(echo "$RULES" | jq -r --arg tg "$TARGET_GROUP_ARN" '.Rules[]|select(.Actions[]?.TargetGroupArn==$tg)|.RuleArn' | head -1)
          
          if [ -n "$TG_RULE" ]; then
            echo "âœ… TG already associated (rule: $TG_RULE)"
          else
            echo "ðŸ“ Creating listener rule..."
            
            # Determine priority
            if [ -n "$LISTENER_RULE_PRIORITY" ]; then
              PRIORITY="$LISTENER_RULE_PRIORITY"
            else
              MAX_P=$(echo "$RULES" | jq '[.Rules[]|select(.Priority!="default")|.Priority|tonumber]|max // 0')
              PRIORITY=$((MAX_P + 1))
            fi
            
            # Build conditions
            COND_FILE=$(mktemp)
            if [ -n "$LISTENER_RULE_HOST" ] && [ -n "$LISTENER_RULE_PATH" ]; then
              jq -n --arg h "$LISTENER_RULE_HOST" --arg p "$LISTENER_RULE_PATH" \
                '[{Field:"host-header",HostHeaderConfig:{Values:[$h]}},{Field:"path-pattern",PathPatternConfig:{Values:[$p]}}]' > "$COND_FILE"
              DESC="Host:$LISTENER_RULE_HOST AND Path:$LISTENER_RULE_PATH"
            elif [ -n "$LISTENER_RULE_HOST" ]; then
              jq -n --arg h "$LISTENER_RULE_HOST" '[{Field:"host-header",HostHeaderConfig:{Values:[$h]}}]' > "$COND_FILE"
              DESC="Host:$LISTENER_RULE_HOST"
            else
              PATH="${LISTENER_RULE_PATH:-/${SERVICE}*}"
              jq -n --arg p "$PATH" '[{Field:"path-pattern",PathPatternConfig:{Values:[$p]}}]' > "$COND_FILE"
              DESC="Path:$PATH"
            fi
            
            echo "   Priority: $PRIORITY | Condition: $DESC"
            RULE_ARN=$(aws elbv2 create-rule --listener-arn "$LISTENER_ARN" --priority "$PRIORITY" \
              --conditions "file://${COND_FILE}" --actions "Type=forward,TargetGroupArn=$TARGET_GROUP_ARN" \
              --query 'Rules[0].RuleArn' --output text)
            rm -f "$COND_FILE"
            echo "âœ… Rule created: $RULE_ARN"
          fi

      - name: Deploy ECS Service
        id: ecs-deploy
        env:
          CLUSTER: ${{ inputs.ecs_cluster || secrets.ECS_CLUSTER }}
          SERVICE: ${{ inputs.ecs_service }}
          NEW_TASK_ARN: ${{ steps.task-def.outputs.task_definition_arn }}
          SERVICE_EXISTS: ${{ steps.task-def.outputs.service_exists }}
          SERVICE_TYPE: ${{ inputs.service_type }}
          TARGET_GROUP_ARN: ${{ steps.target-group.outputs.target_group_arn }}
          CONTAINER_NAME: ${{ inputs.container_name || 'app' }}
          CONTAINER_PORT: ${{ inputs.container_port || '80' }}
          SUBNET_IDS: ${{ inputs.subnet_ids }}
          SECURITY_GROUPS: ${{ inputs.security_group_ids }}
          DESIRED_COUNT: ${{ inputs.desired_count || '1' }}
          ASSIGN_PUBLIC_IP: ${{ inputs.assign_public_ip || 'DISABLED' }}
          ENABLE_ZONE_REBALANCING: ${{ inputs.enable_zone_rebalancing }}
          HEALTH_GRACE_PERIOD: ${{ inputs.health_check_grace_period_seconds }}
          CIRCUIT_BREAKER_ENABLE: ${{ inputs.deployment_circuit_breaker_enable }}
          CIRCUIT_BREAKER_ROLLBACK: ${{ inputs.deployment_circuit_breaker_rollback }}
          CAPACITY_PROVIDER_STRATEGY: ${{ inputs.capacity_provider_strategy }}
          PLATFORM_VERSION: ${{ inputs.platform_version }}
          ENABLE_EXEC_COMMAND: ${{ inputs.enable_execute_command }}
          DEPLOY_MIN_HEALTHY: ${{ inputs.deployment_minimum_healthy_percent }}
          DEPLOY_MAX_PERCENT: ${{ inputs.deployment_maximum_percent }}
        run: |
          set -e
          PORT_NUM=$(echo "$CONTAINER_PORT" | grep -E '^[0-9]+$' || echo "80")
          
          # Deployment config
          DEPLOY_CFG=""
          if [ "$CIRCUIT_BREAKER_ENABLE" = "true" ] || [ -n "$DEPLOY_MIN_HEALTHY" ] || [ -n "$DEPLOY_MAX_PERCENT" ]; then
            CFG_FILE=$(mktemp)
            CFG=$(jq -n '{}')
            if [ "$CIRCUIT_BREAKER_ENABLE" = "true" ]; then
              RB="false"; [ "$CIRCUIT_BREAKER_ROLLBACK" = "true" ] && RB="true"
              CFG=$(echo "$CFG" | jq --argjson rb "$RB" '.+{deploymentCircuitBreaker:{enable:true,rollback:$rb}}')
            fi
            [ -n "$DEPLOY_MIN_HEALTHY" ] && CFG=$(echo "$CFG" | jq --argjson m "$DEPLOY_MIN_HEALTHY" '.+{minimumHealthyPercent:$m}')
            [ -n "$DEPLOY_MAX_PERCENT" ] && CFG=$(echo "$CFG" | jq --argjson m "$DEPLOY_MAX_PERCENT" '.+{maximumPercent:$m}')
            echo "$CFG" > "$CFG_FILE"
            DEPLOY_CFG="--deployment-configuration file://${CFG_FILE}"
          fi
          
          # Capacity provider
          LAUNCH=""
          if [ -n "$CAPACITY_PROVIDER_STRATEGY" ]; then
            CP_FILE=$(mktemp)
            echo "[" > "$CP_FILE"
            FIRST=true
            IFS=',' read -ra PARTS <<< "$CAPACITY_PROVIDER_STRATEGY"
            for part in "${PARTS[@]}"; do
              prov=$(echo "$part"|cut -d':' -f1); base=$(echo "$part"|cut -d':' -f2); weight=$(echo "$part"|cut -d':' -f3)
              [ -z "$base" ] && base=0; [ -z "$weight" ] && weight=1
              [ "$FIRST" = true ] && FIRST=false || echo "," >> "$CP_FILE"
              jq -n --arg p "$prov" --argjson w "$weight" --argjson b "$base" '{capacityProvider:$p,weight:$w,base:$b}' >> "$CP_FILE"
            done
            echo "]" >> "$CP_FILE"
            LAUNCH="--capacity-provider-strategy file://${CP_FILE}"
          else
            LAUNCH="--launch-type FARGATE"
          fi
          
          if [ "$SERVICE_EXISTS" = "true" ]; then
            echo "ðŸ”„ Updating service..."
            CMD="aws ecs update-service --cluster $CLUSTER --service $SERVICE --task-definition $NEW_TASK_ARN --force-new-deployment"
            [ "$ENABLE_ZONE_REBALANCING" = "true" ] && CMD="$CMD --availability-zone-rebalancing ENABLED"
            [ -n "$HEALTH_GRACE_PERIOD" ] && CMD="$CMD --health-check-grace-period-seconds $HEALTH_GRACE_PERIOD"
            [ -n "$PLATFORM_VERSION" ] && CMD="$CMD --platform-version $PLATFORM_VERSION"
            [ "$ENABLE_EXEC_COMMAND" = "true" ] && CMD="$CMD --enable-execute-command"
            [ -n "$DEPLOY_CFG" ] && CMD="$CMD $DEPLOY_CFG"
            $CMD --query 'service.serviceArn' --output text
          else
            echo "ðŸ†• Creating service..."
            [ -z "$SUBNET_IDS" ] || [ -z "$SECURITY_GROUPS" ] && echo "âŒ subnet_ids and security_group_ids are required" && exit 1
            
            SUBNETS=$(echo "$SUBNET_IDS" | tr ',' '\n' | jq -R . | jq -s .)
            SGS=$(echo "$SECURITY_GROUPS" | tr ',' '\n' | jq -R . | jq -s .)
            NET_FILE=$(mktemp)
            jq -n --argjson s "$SUBNETS" --argjson g "$SGS" --arg a "$ASSIGN_PUBLIC_IP" \
              '{awsvpcConfiguration:{subnets:$s,securityGroups:$g,assignPublicIp:$a}}' > "$NET_FILE"
            
            if [ "$SERVICE_TYPE" = "api" ] && [ -n "$TARGET_GROUP_ARN" ]; then
              LB_FILE=$(mktemp)
              jq -n --arg tg "$TARGET_GROUP_ARN" --arg cn "$CONTAINER_NAME" --argjson cp "$PORT_NUM" \
                '[{targetGroupArn:$tg,containerName:$cn,containerPort:$cp}]' > "$LB_FILE"
              aws ecs create-service --cluster "$CLUSTER" --service-name "$SERVICE" --task-definition "$NEW_TASK_ARN" \
                --desired-count "${DESIRED_COUNT:-1}" --network-configuration "file://${NET_FILE}" \
                --load-balancers "file://${LB_FILE}" $LAUNCH --query 'service.serviceArn' --output text
              rm -f "$LB_FILE"
            else
              aws ecs create-service --cluster "$CLUSTER" --service-name "$SERVICE" --task-definition "$NEW_TASK_ARN" \
                --desired-count "${DESIRED_COUNT:-1}" --network-configuration "file://${NET_FILE}" \
                $LAUNCH --query 'service.serviceArn' --output text
            fi
            rm -f "$NET_FILE"
          fi
          
          # Cleanup temp files
          [ -n "$CFG_FILE" ] && rm -f "$CFG_FILE" 2>/dev/null || true
          [ -n "$CP_FILE" ] && rm -f "$CP_FILE" 2>/dev/null || true

      - name: Wait for stabilization
        id: finalize
        env:
          CLUSTER: ${{ inputs.ecs_cluster || secrets.ECS_CLUSTER }}
          SERVICE: ${{ inputs.ecs_service }}
        run: |
          echo "â³ Waiting for deployment to stabilize..."
          aws ecs wait services-stable --cluster "$CLUSTER" --services "$SERVICE"
          SERVICE_ARN=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query 'services[0].serviceArn' --output text)
          echo "service_arn=${SERVICE_ARN}" >> $GITHUB_OUTPUT
          echo "âœ… Deployment complete: $SERVICE_ARN"

      - name: Generate deploy metadata
        id: metadata
        if: success()
        run: |
          ARTIFACT_NAME="deploy-${{ inputs.environment }}-${{ inputs.ecs_service }}-${{ github.run_id }}"
          mkdir -p .deploys
          jq -n \
            --arg env "${{ inputs.environment }}" \
            --arg svc "${{ inputs.ecs_service }}" \
            --arg img "${{ inputs.image_uri }}" \
            --arg td "${{ steps.task-def.outputs.task_definition_arn }}" \
            --arg sa "${{ steps.finalize.outputs.service_arn }}" \
            --arg sha "${{ github.sha }}" \
            --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg rid "${{ github.run_id }}" \
            '{environment:$env,ecs_service:$svc,image_uri:$img,task_definition_arn:$td,service_arn:$sa,commit_sha:$sha,timestamp:$ts,run_id:$rid}' \
            > .deploys/deploy.json
          echo "artifact_name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT

      - name: Upload deploy metadata
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: deploy-${{ inputs.environment }}-${{ inputs.ecs_service }}-${{ github.run_id }}
          path: .deploys
