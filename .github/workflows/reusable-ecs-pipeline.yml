name: Reusable ECS Pipeline

on:
  workflow_call:
    inputs:
      ecs_service:
        description: 'Nome do service ECS e da task definition family (ex.: inbound-nfe-api-envioxml)'
        required: true
        type: string
      service_type:
        description: 'Tipo de servi√ßo: api ou worker'
        required: true
        type: string
      ecr_repo:
        description: 'Nome do reposit√≥rio ECR onde a imagem ser√° enviada (ex.: inbound ou inbound-nfe-api-envioxml)'
        required: true
        type: string
      ecr_registry:
        description: 'URL do registry ECR (ex.: vars.ECR_REGISTRY). Se vazio, usa o registry retornado pelo login ECR.'
        required: false
        type: string
        default: ''
      environment:
        description: 'Ambiente (dev|qa|sbx|prd); caller passa github.ref_name'
        required: true
        type: string
      use_default_dockerfile:
        description: 'true = Dockerfile do repo de templates (build/); false = do repo da aplica√ß√£o'
        required: false
        type: boolean
        default: true
      templates_repo:
        description: 'Repo dos templates (ex.: org/github-ecs); usado quando use_default_dockerfile=true'
        required: false
        type: string
        default: ''
      templates_ref:
        description: 'Branch/tag do repo de templates (ex.: main)'
        required: false
        type: string
        default: 'main'
      project_name:
        description: 'Nome do projeto .csproj (para Dockerfile padr√£o; ex.: Inbound.Nfe.Api.EnvioXml)'
        required: false
        type: string
        default: ''
      dotnet_version:
        description: 'Vers√£o do .NET SDK'
        required: false
        type: string
        default: '8.0'
      working_directory:
        description: 'Diret√≥rio do c√≥digo fonte'
        required: false
        type: string
        default: 'src'
      dockerfile_path:
        description: 'Caminho do Dockerfile (vazio = ./Dockerfile.<service_type> ou ./Dockerfile)'
        required: false
        type: string
        default: ''
      aws_region:
        description: 'Regi√£o AWS'
        required: false
        type: string
        default: 'us-east-1'
      ecs_cluster:
        description: 'Nome do cluster ECS (vazio = usa secret ECS_CLUSTER)'
        required: false
        type: string
        default: ''
      # --- ECS / Fargate: task definition e rede ---
      ecs_task_execution_role_arn:
        description: 'ARN da role de execu√ß√£o da task (obrigat√≥rio para criar/registrar task definition)'
        required: false
        type: string
        default: ''
      ecs_task_role_arn:
        description: 'ARN da role da task (opcional)'
        required: false
        type: string
        default: ''
      task_cpu:
        description: 'CPU para Fargate (256, 512, 1024, 2048, 4096)'
        required: false
        type: string
        default: '256'
      task_memory:
        description: 'Mem√≥ria em MB para Fargate (512, 1024, 2048, 4096, 8192)'
        required: false
        type: string
        default: '512'
      subnet_ids:
        description: 'IDs das subnets separados por v√≠rgula (ex.: subnet-1,subnet-2)'
        required: false
        type: string
        default: ''
      security_group_ids:
        description: 'IDs dos security groups separados por v√≠rgula'
        required: false
        type: string
        default: ''
      assign_public_ip:
        description: 'Atribuir IP p√∫blico (ENABLED/DISABLED) para Fargate'
        required: false
        type: string
        default: 'DISABLED'
      desired_count:
        description: 'N√∫mero desejado de tasks (para create-service)'
        required: false
        type: string
        default: '1'
      # --- API: Load Balancer (ignorado para worker). Modo idempotente: TG e listener s√≥ criados se n√£o existirem ---
      create_target_group_and_listener:
        description: 'Para API: true = obter ou criar target group e listener no ALB (como no console AWS). Idempotente: s√≥ cria se n√£o existir.'
        required: false
        type: boolean
        default: false
      load_balancer_arn:
        description: 'ARN do ALB (para create_target_group_and_listener). Alternativa: load_balancer_name.'
        required: false
        type: string
        default: ''
      load_balancer_name:
        description: 'Nome do ALB existente (pipeline resolve o ARN). Usado quando create_target_group_and_listener=true e load_balancer_arn vazio.'
        required: false
        type: string
        default: ''
      listener_port:
        description: 'Porta do listener (ex.: 80). Idempotente: se j√° existir listener nessa porta apontando para o mesmo TG, nada √© criado.'
        required: false
        type: string
        default: '80'
      listener_protocol:
        description: 'Protocolo do listener (HTTP ou HTTPS). Para HTTPS informe certificate_arn em listener_certificate_arn.'
        required: false
        type: string
        default: 'HTTP'
      listener_certificate_arn:
        description: 'ARN do certificado ACM (obrigat√≥rio se listener_protocol=HTTPS).'
        required: false
        type: string
        default: ''
      target_group_name:
        description: 'Nome do target group. Idempotente: se j√° existir na mesma VPC, o pipeline reutiliza; caso contr√°rio, cria.'
        required: false
        type: string
        default: ''
      target_group_port:
        description: 'Porta do target group (ex.: 80). Deve coincidir com container_port para Fargate.'
        required: false
        type: string
        default: '80'
      target_group_protocol:
        description: 'Protocolo do target group (HTTP ou HTTPS).'
        required: false
        type: string
        default: 'HTTP'
      target_group_health_check_path:
        description: 'Caminho do health check do target group (ex.: / ou /health).'
        required: false
        type: string
        default: '/'
      target_group_health_check_protocol:
        description: 'Protocolo do health check (HTTP ou HTTPS).'
        required: false
        type: string
        default: 'HTTP'
      target_group_deregistration_delay_seconds:
        description: 'Demora no cancelamento do registro (segundos). Ex.: 300.'
        required: false
        type: string
        default: '300'
      container_name:
        description: 'Nome do container na task definition (para mapear ao LB; default: app)'
        required: false
        type: string
        default: 'app'
      container_port:
        description: 'Porta do container exposta ao ALB'
        required: false
        type: string
        default: '80'
      # --- Task definition: environment, secrets, runtime, log ---
      container_environment:
        description: 'JSON array de vari√°veis de ambiente [{ "name": "X", "value": "Y" }]; vazio = nenhuma'
        required: false
        type: string
        default: ''
      container_secrets:
        description: 'JSON array de secrets (Secrets Manager) [{ "name": "X", "valueFrom": "arn:..." }]; vazio = nenhum'
        required: false
        type: string
        default: ''
      runtime_cpu_architecture:
        description: 'CPU da plataforma (X86_64, ARM64); vazio = default Fargate'
        required: false
        type: string
        default: ''
      runtime_os_family:
        description: 'OS da plataforma (LINUX, WINDOWS_SERVER_2019_CORE); vazio = default'
        required: false
        type: string
        default: ''
      awslogs_mode:
        description: 'Modo awslogs (non-blocking ou blocking); vazio = n√£o define'
        required: false
        type: string
        default: ''
      awslogs_create_group:
        description: 'Criar log group se n√£o existir (true/false); vazio = n√£o define'
        required: false
        type: string
        default: ''
      awslogs_max_buffer_size:
        description: 'Tamanho m√°ximo do buffer (ex.: 25m); vazio = n√£o define'
        required: false
        type: string
        default: ''
      port_mapping_app_protocol:
        description: 'appProtocol do portMapping (ex.: http); vazio = n√£o define'
        required: false
        type: string
        default: ''
      # --- Service: rebalanceamento, circuit breaker, capacity provider, ECS Exec ---
      enable_zone_rebalancing:
        description: 'Ativar rebalanceamento de zonas de disponibilidade (true/false)'
        required: false
        type: boolean
        default: false
      health_check_grace_period_seconds:
        description: 'Per√≠odo de car√™ncia do health check em segundos (0 ou positivo)'
        required: false
        type: string
        default: ''
      deployment_circuit_breaker_enable:
        description: 'Habilitar disjuntor de implanta√ß√£o (falha autom√°tica do deploy)'
        required: false
        type: boolean
        default: false
      deployment_circuit_breaker_rollback:
        description: 'Fazer rollback autom√°tico quando o disjuntor disparar (requer enable)'
        required: false
        type: boolean
        default: false
      capacity_provider_strategy:
        description: 'Estrat√©gia de capacity providers (ex.: FARGATE=1,FARGATE_SPOT=4 ou JSON); vazio = launch-type FARGATE'
        required: false
        type: string
        default: ''
      platform_version:
        description: 'Vers√£o da plataforma Fargate (ex.: 1.4.0); vazio = default AWS'
        required: false
        type: string
        default: ''
      enable_execute_command:
        description: 'Ativar ECS Exec (comandos interativos no container)'
        required: false
        type: boolean
        default: false
      deployment_minimum_healthy_percent:
        description: 'M√≠nimo % de tarefas saud√°veis durante deploy (ex.: 100); vazio = default AWS'
        required: false
        type: string
        default: ''
      deployment_maximum_percent:
        description: 'M√°ximo % de tarefas durante deploy (ex.: 200); vazio = default AWS'
        required: false
        type: string
        default: ''
      # --- Fim ECS/LB ---
      enable_health_check:
        description: 'Executar health check HTTP p√≥s-deploy (opcional)'
        required: false
        type: boolean
        default: false
      health_check_url:
        description: 'URL do health check (ex.: https://api-dev.example.com/health)'
        required: false
        type: string
        default: ''
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      ECS_CLUSTER:
        required: false
      ECS_TASK_EXECUTION_ROLE_ARN:
        required: false
      REPO_ACCESS_TOKEN:
        required: false
    outputs:
      image_digest:
        description: 'Digest da imagem no ECR'
        value: ${{ jobs.pipeline.outputs.image_digest }}
      image_tag:
        description: 'Tag da imagem (SHA)'
        value: ${{ jobs.pipeline.outputs.image_tag }}
      deployed_service_arn:
        description: 'ARN do service ECS atualizado ou criado'
        value: ${{ jobs.pipeline.outputs.deployed_service_arn }}
      task_definition_arn:
        description: 'ARN da task definition registrada neste deploy (para rollback)'
        value: ${{ jobs.pipeline.outputs.task_definition_arn }}

jobs:
  pipeline:
    name: Build, Test, Docker, ECR, ECS
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    continue-on-error: false
    outputs:
      image_digest: ${{ steps.ecr-push.outputs.image_digest }}
      image_tag: ${{ steps.ecr-push.outputs.image_tag }}
      deployed_service_arn: ${{ steps.ecs-deploy.outputs.service_arn }}
      task_definition_arn: ${{ steps.ecs-deploy.outputs.task_definition_arn }}

    steps:
      - name: Validar ambiente e service
        id: validate
        run: |
          ENV="${{ inputs.environment }}"
          case "$ENV" in
            dev|qa|sbx|prd) echo "‚úÖ Ambiente v√°lido: $ENV" ;;
            *) echo "‚ùå Ambiente inv√°lido: $ENV"; exit 1 ;;
          esac
          SERVICE="${{ inputs.ecs_service }}"
          ECR_REPO="${{ inputs.ecr_repo }}"
          if [ -z "$SERVICE" ]; then
            echo "‚ùå ecs_service √© obrigat√≥rio"
            exit 1
          fi
          if [ -z "$ECR_REPO" ]; then
            echo "‚ùå ecr_repo √© obrigat√≥rio"
            exit 1
          fi
          echo "ecr_repository=${ECR_REPO}" >> $GITHUB_OUTPUT
          echo "ecr_registry=${{ inputs.ecr_registry }}" >> $GITHUB_OUTPUT
          echo "ecs_service=${SERVICE}" >> $GITHUB_OUTPUT

      - name: Checkout aplica√ß√£o
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ inputs.dotnet_version }}

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles(format('{0}/**/*.csproj', inputs.working_directory)) }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore
        working-directory: ${{ inputs.working_directory }}
        run: dotnet restore

      - name: Test
        working-directory: ${{ inputs.working_directory }}
        run: dotnet test --no-restore --verbosity normal

      - name: Checkout templates (Dockerfile padr√£o)
        if: inputs.use_default_dockerfile == true && inputs.templates_repo != ''
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.templates_repo }}
          ref: ${{ inputs.templates_ref }}
          path: .ci-templates
          token: ${{ secrets.REPO_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Definir caminho do Dockerfile
        id: dockerfile-path
        run: |
          if [ "${{ inputs.use_default_dockerfile }}" = "true" ] && [ -n "${{ inputs.templates_repo }}" ]; then
            echo "dockerfile=.ci-templates/build/Dockerfile.${{ inputs.service_type }}" >> $GITHUB_OUTPUT
            echo "‚úÖ Usando Dockerfile padr√£o do repo de templates (build/Dockerfile.${{ inputs.service_type }})"
          else
            CUSTOM="${{ inputs.dockerfile_path }}"
            [ -z "$CUSTOM" ] && CUSTOM="Dockerfile.${{ inputs.service_type }}"
            [ -z "$CUSTOM" ] && CUSTOM="Dockerfile"
            echo "dockerfile=${CUSTOM}" >> $GITHUB_OUTPUT
            echo "‚úÖ Usando Dockerfile do repo da aplica√ß√£o: ${CUSTOM}"
          fi

      - name: Build Docker image
        id: docker-build
        run: |
          BUILD_ARGS=""
          if [ -n "${{ inputs.project_name }}" ]; then
            BUILD_ARGS="--build-arg PROJECT_NAME=${{ inputs.project_name }}"
          fi
          docker build -t ci-build -f ${{ steps.dockerfile-path.outputs.dockerfile }} $BUILD_ARGS .
          echo "‚úÖ Image built locally (tag: ci-build)"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Definir registry ECR
        id: registry
        run: |
          REGISTRY="${{ steps.validate.outputs.ecr_registry }}"
          if [ -z "$REGISTRY" ]; then
            REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          fi
          if [ -z "$REGISTRY" ]; then
            echo "‚ùå Registry ECR vazio. Configure vars.ECR_REGISTRY ou verifique o login ECR."
            exit 1
          fi
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "‚úÖ Registry: ${REGISTRY}"

      - name: Tag and Push to ECR
        id: ecr-push
        env:
          ECR_REPO: ${{ steps.validate.outputs.ecr_repository }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
        run: |
          FULL_IMAGE="${REGISTRY}/${ECR_REPO}:${{ github.sha }}"
          docker tag ci-build "$FULL_IMAGE"
          docker push "$FULL_IMAGE"
          docker tag ci-build "${REGISTRY}/${ECR_REPO}:${{ github.ref_name }}"
          docker push "${REGISTRY}/${ECR_REPO}:${{ github.ref_name }}"
          TIMESTAMP_TAG="$(date -u +%Y%m%d-%H%M%S)"
          docker tag ci-build "${REGISTRY}/${ECR_REPO}:${TIMESTAMP_TAG}"
          docker push "${REGISTRY}/${ECR_REPO}:${TIMESTAMP_TAG}"
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ci-build | cut -d'@' -f2)
          echo "image_digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "‚úÖ Pushed $FULL_IMAGE"

      - name: Registrar nova Task Definition e Deploy (criar ou atualizar service)
        id: ecs-deploy
        env:
          CLUSTER: ${{ inputs.ecs_cluster || secrets.ECS_CLUSTER }}
          SERVICE: ${{ steps.validate.outputs.ecs_service }}
          REGISTRY: ${{ steps.registry.outputs.registry }}
          ECR_REPO: ${{ steps.validate.outputs.ecr_repository }}
          IMAGE_TAG: ${{ steps.ecr-push.outputs.image_tag }}
          TASK_EXEC_ROLE: ${{ inputs.ecs_task_execution_role_arn || secrets.ECS_TASK_EXECUTION_ROLE_ARN }}
          TASK_ROLE: ${{ inputs.ecs_task_role_arn }}
          CONTAINER_NAME: ${{ inputs.container_name || 'app' }}
          CONTAINER_PORT: ${{ inputs.container_port || '80' }}
          SUBNET_IDS: ${{ inputs.subnet_ids }}
          SECURITY_GROUPS: ${{ inputs.security_group_ids }}
          DESIRED_COUNT: ${{ inputs.desired_count || '1' }}
          ASSIGN_PUBLIC_IP: ${{ inputs.assign_public_ip || 'DISABLED' }}
          CREATE_TG_AND_LISTENER: ${{ inputs.create_target_group_and_listener }}
          LOAD_BALANCER_ARN: ${{ inputs.load_balancer_arn }}
          LOAD_BALANCER_NAME: ${{ inputs.load_balancer_name }}
          LISTENER_PORT: ${{ inputs.listener_port }}
          LISTENER_PROTOCOL: ${{ inputs.listener_protocol }}
          LISTENER_CERTIFICATE_ARN: ${{ inputs.listener_certificate_arn }}
          TG_NAME: ${{ inputs.target_group_name }}
          TG_PORT: ${{ inputs.target_group_port }}
          TG_PROTOCOL: ${{ inputs.target_group_protocol }}
          TG_HEALTH_CHECK_PATH: ${{ inputs.target_group_health_check_path }}
          TG_HEALTH_CHECK_PROTOCOL: ${{ inputs.target_group_health_check_protocol }}
          TG_DEREGISTRATION_DELAY: ${{ inputs.target_group_deregistration_delay_seconds }}
          SERVICE_TYPE: ${{ inputs.service_type }}
          AWS_REGION: ${{ inputs.aws_region }}
          CONTAINER_ENVIRONMENT: ${{ inputs.container_environment }}
          CONTAINER_SECRETS: ${{ inputs.container_secrets }}
          RUNTIME_CPU: ${{ inputs.runtime_cpu_architecture }}
          RUNTIME_OS: ${{ inputs.runtime_os_family }}
          AWSLOGS_MODE: ${{ inputs.awslogs_mode }}
          AWSLOGS_CREATE_GROUP: ${{ inputs.awslogs_create_group }}
          AWSLOGS_MAX_BUFFER: ${{ inputs.awslogs_max_buffer_size }}
          PORT_APP_PROTOCOL: ${{ inputs.port_mapping_app_protocol }}
          ENABLE_ZONE_REBALANCING: ${{ inputs.enable_zone_rebalancing }}
          HEALTH_GRACE_PERIOD: ${{ inputs.health_check_grace_period_seconds }}
          CIRCUIT_BREAKER_ENABLE: ${{ inputs.deployment_circuit_breaker_enable }}
          CIRCUIT_BREAKER_ROLLBACK: ${{ inputs.deployment_circuit_breaker_rollback }}
          CAPACITY_PROVIDER_STRATEGY: ${{ inputs.capacity_provider_strategy }}
          PLATFORM_VERSION: ${{ inputs.platform_version }}
          ENABLE_EXEC_COMMAND: ${{ inputs.enable_execute_command }}
          DEPLOY_MIN_HEALTHY: ${{ inputs.deployment_minimum_healthy_percent }}
          DEPLOY_MAX_PERCENT: ${{ inputs.deployment_maximum_percent }}
        run: |
          set -e
          FULL_IMAGE="${REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"
          echo "üñºÔ∏è Imagem: $FULL_IMAGE"
          if [ -z "$CLUSTER" ] || [ -z "$SERVICE" ]; then
            echo "‚ùå ECS cluster e ecs_service s√£o obrigat√≥rios (ecs_cluster ou secret ECS_CLUSTER)"
            exit 1
          fi

          # Verificar se o service j√° existe (define fluxo: reutilizar task def vs criar do zero)
          EXISTING=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query 'services[?status==`ACTIVE`]' --output json)
          SERVICE_EXISTS=$(echo "$EXISTING" | jq 'length > 0')

          if [ "$SERVICE_EXISTS" = "true" ]; then
            # --- Service existe: reutilizar task definition atual, trocar s√≥ imagem e environment (se informado) ---
            echo "üîÑ Service j√° existe: reutilizando task definition e trocando imagem (e environment se informado)..."
            if [ -z "$TASK_EXEC_ROLE" ]; then
              echo "‚ö†Ô∏è Role de execu√ß√£o n√£o informada; task definition atual ser√° preservada (incl. executionRoleArn)"
            fi
            CURRENT_TASK_ARN=$(echo "$EXISTING" | jq -r '.[0].taskDefinition')
            TASK_DEF_JSON=$(aws ecs describe-task-definition --task-definition "$CURRENT_TASK_ARN" --query 'taskDefinition' --output json)
            # Remover campos read-only para re-registro
            TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
            # Trocar imagem do primeiro container
            TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --arg img "$FULL_IMAGE" '.containerDefinitions[0].image = $img')
            # Se container_environment foi informado, substituir environment do primeiro container
            if [ -n "$CONTAINER_ENVIRONMENT" ] && [ "$CONTAINER_ENVIRONMENT" != "[]" ]; then
              if echo "$CONTAINER_ENVIRONMENT" | jq -e . >/dev/null 2>&1; then
                TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --argjson env "$CONTAINER_ENVIRONMENT" '.containerDefinitions[0].environment = $env')
                echo "üìù Atualizando environment do container com os valores informados"
              fi
            fi
            echo "üìù Registrando nova revis√£o da task definition (imagem + environment se informado)..."
            NEW_TASK_ARN=$(echo "$TASK_DEF_JSON" | aws ecs register-task-definition --cli-input-json file:///dev/stdin --query 'taskDefinition.taskDefinitionArn' --output text)
            echo "task_definition_arn=${NEW_TASK_ARN}" >> $GITHUB_OUTPUT
            echo "‚úÖ Task definition: $NEW_TASK_ARN (reutilizada; imagem e env atualizados)"
          else
            # --- Service n√£o existe: criar task definition do zero (obrigat√≥rio role) ---
            if [ -z "$TASK_EXEC_ROLE" ]; then
              echo "‚ùå Role de execu√ß√£o obrigat√≥ria (input ecs_task_execution_role_arn ou secret ECS_TASK_EXECUTION_ROLE_ARN)"
              exit 1
            fi
            TASK_FAMILY="$SERVICE"
            LOG_GROUP="/ecs/${TASK_FAMILY}"
            PORT_NUM=$(echo "$CONTAINER_PORT" | grep -E '^[0-9]+$' || echo "80")

            PORT_MAPPING=$(jq -n \
              --arg name "${CONTAINER_NAME}-${PORT_NUM}-tcp" \
              --argjson port "$PORT_NUM" \
              --arg appProtocol "$PORT_APP_PROTOCOL" \
              '{
                name: $name,
                containerPort: $port,
                hostPort: $port,
                protocol: "tcp"
              } | if $appProtocol != "" then . + {"appProtocol": $appProtocol} else . end')

            LOG_OPTS=$(jq -n \
              --arg lg "$LOG_GROUP" \
              --arg region "$AWS_REGION" \
              --arg mode "$AWSLOGS_MODE" \
              --arg createGroup "$AWSLOGS_CREATE_GROUP" \
              --arg maxBuf "$AWSLOGS_MAX_BUFFER" \
              '{
                "awslogs-group": $lg,
                "awslogs-region": $region,
                "awslogs-stream-prefix": "ecs"
              } | if $mode != "" then . + {"mode": $mode} else . end | if $createGroup != "" then . + {"awslogs-create-group": $createGroup} else . end | if $maxBuf != "" then . + {"max-buffer-size": $maxBuf} else . end')

            CONTAINER_DEF=$(jq -n \
              --arg name "$CONTAINER_NAME" \
              --arg image "$FULL_IMAGE" \
              --argjson portMapping "$PORT_MAPPING" \
              --argjson logOpts "$LOG_OPTS" \
              '{
                name: $name,
                image: $image,
                portMappings: [$portMapping],
                logConfiguration: { logDriver: "awslogs", options: $logOpts },
                essential: true
              }')

            if [ -n "$CONTAINER_ENVIRONMENT" ] && [ "$CONTAINER_ENVIRONMENT" != "[]" ]; then
              if echo "$CONTAINER_ENVIRONMENT" | jq -e . >/dev/null 2>&1; then
                CONTAINER_DEF=$(echo "$CONTAINER_DEF" | jq --argjson env "$CONTAINER_ENVIRONMENT" '. + {environment: $env}')
              fi
            fi
            if [ -n "$CONTAINER_SECRETS" ] && [ "$CONTAINER_SECRETS" != "[]" ]; then
              if echo "$CONTAINER_SECRETS" | jq -e . >/dev/null 2>&1; then
                CONTAINER_DEF=$(echo "$CONTAINER_DEF" | jq --argjson secrets "$CONTAINER_SECRETS" '. + {secrets: $secrets}')
              fi
            fi

            TASK_DEF_JSON=$(jq -n \
              --arg family "$TASK_FAMILY" \
              --arg execRole "$TASK_EXEC_ROLE" \
              --arg taskRole "$TASK_ROLE" \
              --arg cpu "${{ inputs.task_cpu || '256' }}" \
              --arg memory "${{ inputs.task_memory || '512' }}" \
              --argjson container "$CONTAINER_DEF" \
              --arg runtimeCpu "$RUNTIME_CPU" \
              --arg runtimeOs "$RUNTIME_OS" \
              '{
                family: $family,
                networkMode: "awsvpc",
                requiresCompatibilities: ["FARGATE"],
                cpu: $cpu,
                memory: $memory,
                executionRoleArn: $execRole,
                containerDefinitions: [$container]
              } | if $taskRole != "" then . + {taskRoleArn: $taskRole} else . end | if ($runtimeCpu != "" or $runtimeOs != "") then . + {runtimePlatform: ({} | if $runtimeCpu != "" then . + {cpuArchitecture: $runtimeCpu} else . end | if $runtimeOs != "" then . + {operatingSystemFamily: $runtimeOs} else . end)} else . end')

            echo "üìù Registrando nova revis√£o da task definition (cria√ß√£o do zero)..."
            NEW_TASK_ARN=$(echo "$TASK_DEF_JSON" | aws ecs register-task-definition --cli-input-json file:///dev/stdin --query 'taskDefinition.taskDefinitionArn' --output text)
            echo "task_definition_arn=${NEW_TASK_ARN}" >> $GITHUB_OUTPUT
            echo "‚úÖ Task definition: $NEW_TASK_ARN"
          fi

          # Par√¢metros comuns para create-service e update-service (novos cen√°rio real ECS)
          EXTRA_UPDATE_ARGS=""
          [ "$ENABLE_ZONE_REBALANCING" = "true" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --enable-zone-rebalancing"
          [ -n "$HEALTH_GRACE_PERIOD" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --health-check-grace-period-seconds $HEALTH_GRACE_PERIOD"
          if [ "$CIRCUIT_BREAKER_ENABLE" = "true" ]; then
            EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --deployment-circuit-breaker enable=$CIRCUIT_BREAKER_ENABLE,rollback=$CIRCUIT_BREAKER_ROLLBACK"
          fi
          [ -n "$PLATFORM_VERSION" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --platform-version $PLATFORM_VERSION"
          [ "$ENABLE_EXEC_COMMAND" = "true" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --enable-execute-command"
          if [ -n "$DEPLOY_MIN_HEALTHY" ] || [ -n "$DEPLOY_MAX_PERCENT" ]; then
            DEPLOY_CFG=""
            [ -n "$DEPLOY_MIN_HEALTHY" ] && DEPLOY_CFG="minimumHealthyPercent=$DEPLOY_MIN_HEALTHY"
            [ -n "$DEPLOY_MAX_PERCENT" ] && { [ -n "$DEPLOY_CFG" ] && DEPLOY_CFG="$DEPLOY_CFG,maximumPercent=$DEPLOY_MAX_PERCENT" || DEPLOY_CFG="maximumPercent=$DEPLOY_MAX_PERCENT"; }
            [ -n "$DEPLOY_CFG" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --deployment-configuration '$DEPLOY_CFG'"
          fi

          LAUNCH_OR_CAPACITY=""
          if [ -n "$CAPACITY_PROVIDER_STRATEGY" ]; then
            CAP_PARTS=""
            for part in $(echo "$CAPACITY_PROVIDER_STRATEGY" | tr ',' ' '); do
              prov=$(echo "$part" | cut -d':' -f1)
              base=$(echo "$part" | cut -d':' -f2)
              weight=$(echo "$part" | cut -d':' -f3)
              [ -z "$base" ] && base=0
              [ -z "$weight" ] && weight=1
              entry="capacityProvider=$prov,weight=$weight,base=$base"
              CAP_PARTS="$CAP_PARTS \"$entry\""
            done
            LAUNCH_OR_CAPACITY="--capacity-provider-strategy $CAP_PARTS"
          else
            LAUNCH_OR_CAPACITY="--launch-type FARGATE"
          fi

          if [ "$SERVICE_EXISTS" = "true" ]; then
            eval aws ecs update-service \
              --cluster "$CLUSTER" \
              --service "$SERVICE" \
              --task-definition "$NEW_TASK_ARN" \
              --force-new-deployment \
              $EXTRA_UPDATE_ARGS \
              --query 'service.serviceArn' \
              --output text
          else
            echo "üÜï Service n√£o existe: criando service e registrando no cluster..."
            if [ -z "$SUBNET_IDS" ] || [ -z "$SECURITY_GROUPS" ]; then
              echo "‚ùå Para criar o service s√£o obrigat√≥rios: subnet_ids e security_group_ids"
              exit 1
            fi

            # --- API: obter ou criar target group e listener (idempotente, como no console AWS) ---
            TARGET_GROUP_ARN=""
            if [ "$SERVICE_TYPE" = "api" ]; then
              if [ "$CREATE_TG_AND_LISTENER" != "true" ] || [ -z "$TG_NAME" ]; then
                echo "‚ùå Para API com Load Balancer √© obrigat√≥rio: create_target_group_and_listener=true, target_group_name e load_balancer_arn ou load_balancer_name"
                exit 1
              fi
              if [ -z "$LOAD_BALANCER_ARN" ] && [ -n "$LOAD_BALANCER_NAME" ]; then
                LOAD_BALANCER_ARN=$(aws elbv2 describe-load-balancers --names "$LOAD_BALANCER_NAME" --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || true)
                if [ -z "$LOAD_BALANCER_ARN" ] || [ "$LOAD_BALANCER_ARN" = "None" ]; then
                  echo "‚ùå Load balancer com nome '$LOAD_BALANCER_NAME' n√£o encontrado"
                  exit 1
                fi
                echo "‚úÖ Load balancer encontrado: $LOAD_BALANCER_ARN"
              fi
              if [ -z "$LOAD_BALANCER_ARN" ]; then
                echo "‚ùå Informe load_balancer_arn ou load_balancer_name"
                exit 1
              fi
              FIRST_SUBNET=$(echo "$SUBNET_IDS" | cut -d',' -f1)
              VPC_ID=$(aws ec2 describe-subnets --subnet-ids "$FIRST_SUBNET" --query 'Subnets[0].VpcId' --output text 2>/dev/null || true)
              if [ -z "$VPC_ID" ] || [ "$VPC_ID" = "None" ]; then
                echo "‚ùå N√£o foi poss√≠vel obter VPC das subnets"
                exit 1
              fi
              TG_PORT_NUM=${TG_PORT:-80}
              TG_DEREG=${TG_DEREGISTRATION_DELAY:-300}
              # Idempot√™ncia TG: usar existente se encontrar pelo nome na mesma VPC
              EXISTING_TG_JSON=$(aws elbv2 describe-target-groups --names "$TG_NAME" --query 'TargetGroups[0]' --output json 2>/dev/null || echo "null")
              if [ -n "$EXISTING_TG_JSON" ] && [ "$EXISTING_TG_JSON" != "null" ]; then
                EXISTING_VPC=$(echo "$EXISTING_TG_JSON" | jq -r '.VpcId')
                if [ "$EXISTING_VPC" = "$VPC_ID" ]; then
                  TARGET_GROUP_ARN=$(echo "$EXISTING_TG_JSON" | jq -r '.TargetGroupArn')
                  echo "‚úÖ Target group j√° existe: $TARGET_GROUP_ARN"
                else
                  echo "‚ùå Target group com nome '$TG_NAME' j√° existe em outra VPC ($EXISTING_VPC). Use outro target_group_name ou a mesma VPC."
                  exit 1
                fi
              fi
              if [ -z "$TARGET_GROUP_ARN" ]; then
                echo "üìù Criando target group: $TG_NAME (porta $TG_PORT_NUM, VPC $VPC_ID)..."
                TARGET_GROUP_ARN=$(aws elbv2 create-target-group \
                  --name "$TG_NAME" \
                  --protocol "${TG_PROTOCOL:-HTTP}" \
                  --port "$TG_PORT_NUM" \
                  --vpc-id "$VPC_ID" \
                  --target-type ip \
                  --health-check-path "${TG_HEALTH_CHECK_PATH:-/}" \
                  --health-check-protocol "${TG_HEALTH_CHECK_PROTOCOL:-HTTP}" \
                  --deregistration-delay-seconds "$TG_DEREG" \
                  --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || true)
                if [ -z "$TARGET_GROUP_ARN" ] || [ "$TARGET_GROUP_ARN" = "None" ]; then
                  echo "‚ùå Falha ao criar target group"
                  exit 1
                fi
                echo "‚úÖ Target group criado: $TARGET_GROUP_ARN"
              fi
              LISTENER_PORT_NUM=${LISTENER_PORT:-80}
              EXISTING_LISTENER_JSON=$(aws elbv2 describe-listeners --load-balancer-arn "$LOAD_BALANCER_ARN" --query "Listeners[?Port==\`$LISTENER_PORT_NUM\`]" --output json 2>/dev/null | jq '.[0]' 2>/dev/null || echo "null")
              if [ -n "$EXISTING_LISTENER_JSON" ] && [ "$EXISTING_LISTENER_JSON" != "null" ]; then
                EXISTING_TG_ARN=$(echo "$EXISTING_LISTENER_JSON" | jq -r '.DefaultActions[0].TargetGroupArn')
                if [ "$EXISTING_TG_ARN" = "$TARGET_GROUP_ARN" ]; then
                  echo "‚úÖ Listener na porta $LISTENER_PORT_NUM j√° existe e aponta para este target group"
                else
                  echo "‚ùå J√° existe um listener na porta $LISTENER_PORT_NUM neste ALB apontando para outro target group. Use outra porta (listener_port) ou o target_group_name correspondente."
                  exit 1
                fi
              else
                echo "üìù Criando listener na porta $LISTENER_PORT_NUM (${LISTENER_PROTOCOL:-HTTP})..."
                if [ "${LISTENER_PROTOCOL}" = "HTTPS" ] && [ -n "$LISTENER_CERTIFICATE_ARN" ]; then
                  aws elbv2 create-listener \
                    --load-balancer-arn "$LOAD_BALANCER_ARN" \
                    --port "$LISTENER_PORT_NUM" \
                    --protocol HTTPS \
                    --certificates "CertificateArn=$LISTENER_CERTIFICATE_ARN" \
                    --default-actions "Type=forward,TargetGroupArn=$TARGET_GROUP_ARN" \
                    --output text >/dev/null
                else
                  aws elbv2 create-listener \
                    --load-balancer-arn "$LOAD_BALANCER_ARN" \
                    --port "$LISTENER_PORT_NUM" \
                    --protocol "${LISTENER_PROTOCOL:-HTTP}" \
                    --default-actions "Type=forward,TargetGroupArn=$TARGET_GROUP_ARN" \
                    --output text >/dev/null
                fi
                echo "‚úÖ Listener criado"
              fi
            fi

            SUBNETS=$(echo "$SUBNET_IDS" | tr ',' '\n' | jq -R . | jq -s .)
            SGS=$(echo "$SECURITY_GROUPS" | tr ',' '\n' | jq -R . | jq -s .)
            NETWORK_CONFIG=$(jq -n \
              --argjson subnets "$SUBNETS" \
              --argjson sgs "$SGS" \
              --arg assign "$ASSIGN_PUBLIC_IP" \
              '{ awsvpcConfiguration: { subnets: $subnets, securityGroups: $sgs, assignPublicIp: $assign } }')

            if [ "$SERVICE_TYPE" = "api" ] && [ -n "$TARGET_GROUP_ARN" ]; then
              echo "üìå API com Load Balancer: target group $TARGET_GROUP_ARN"
              LB_JSON=$(jq -n \
                --arg tg "$TARGET_GROUP_ARN" \
                --arg cn "$CONTAINER_NAME" \
                --argjson cp "$PORT_NUM" \
                '[{ targetGroupArn: $tg, containerName: $cn, containerPort: $cp }]')
              eval aws ecs create-service \
                --cluster "$CLUSTER" \
                --service-name "$SERVICE" \
                --task-definition "$NEW_TASK_ARN" \
                --desired-count "$(echo "$DESIRED_COUNT" | sed 's/^0*//' || echo 1)" \
                --network-configuration "$NETWORK_CONFIG" \
                --load-balancers "$LB_JSON" \
                $EXTRA_UPDATE_ARGS \
                $LAUNCH_OR_CAPACITY \
                --query 'service.serviceArn' \
                --output text
            else
              echo "üìå Worker (sem Load Balancer)"
              eval aws ecs create-service \
                --cluster "$CLUSTER" \
                --service-name "$SERVICE" \
                --task-definition "$NEW_TASK_ARN" \
                --desired-count "$(echo "$DESIRED_COUNT" | sed 's/^0*//' || echo 1)" \
                --network-configuration "$NETWORK_CONFIG" \
                $EXTRA_UPDATE_ARGS \
                $LAUNCH_OR_CAPACITY \
                --query 'service.serviceArn' \
                --output text
            fi
          fi

          echo "service_arn=$(aws ecs describe-services --cluster $CLUSTER --services $SERVICE --query 'services[0].serviceArn' --output text)" >> $GITHUB_OUTPUT
          echo "‚è≥ Aguardando deployment estabilizar..."
          aws ecs wait services-stable --cluster "$CLUSTER" --services "$SERVICE"
          echo "‚úÖ Deployment conclu√≠do"

      - name: Gerar deploy metadata (hist√≥rico e rollback)
        id: deploy-meta
        if: success()
        run: |
          mkdir -p .deploys
          cat << EOF > .deploys/deploy.json
          {
            "environment": "${{ inputs.environment }}",
            "ecs_service": "${{ inputs.ecs_service }}",
            "image_digest": "${{ steps.ecr-push.outputs.image_digest }}",
            "image_tag": "${{ steps.ecr-push.outputs.image_tag }}",
            "task_definition_arn": "${{ steps.ecs-deploy.outputs.task_definition_arn }}",
            "service_arn": "${{ steps.ecs-deploy.outputs.service_arn }}",
            "commit_sha": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "run_id": "${{ github.run_id }}",
            "run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF
          echo "path=.deploys" >> $GITHUB_OUTPUT

      - name: Upload deploy metadata
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: deploy-${{ inputs.environment }}-${{ inputs.ecs_service }}-${{ github.run_id }}
          path: .deploys

      - name: Health check (opcional)
        if: inputs.enable_health_check == true && inputs.health_check_url != ''
        run: |
          URL="${{ inputs.health_check_url }}"
          MAX_ATTEMPTS=12
          INTERVAL=10
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if curl -sf "$URL" > /dev/null; then
              echo "‚úÖ Health check OK em $URL"
              exit 0
            fi
            echo "Tentativa $i/$MAX_ATTEMPTS falhou; aguardando ${INTERVAL}s..."
            sleep $INTERVAL
          done
          echo "‚ùå Health check falhou ap√≥s $MAX_ATTEMPTS tentativas"
          exit 1
