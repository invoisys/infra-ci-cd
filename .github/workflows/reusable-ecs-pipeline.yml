name: Reusable ECS Pipeline

on:
  workflow_call:
    inputs:
      ecs_service:
        description: 'Nome do service ECS e da task definition family'
        required: true
        type: string
      service_type:
        description: 'Tipo de servi√ßo: api ou worker'
        required: true
        type: string
      ecr_repo:
        description: 'Nome do reposit√≥rio ECR'
        required: true
        type: string
      ecr_registry:
        description: 'URL do registry ECR'
        required: false
        type: string
        default: ''
      environment:
        description: 'Ambiente (dev|qa|sbx|prd)'
        required: true
        type: string
      use_default_dockerfile:
        description: 'true = Dockerfile do repo de templates'
        required: false
        type: boolean
        default: true
      templates_repo:
        description: 'Repo dos templates'
        required: false
        type: string
        default: ''
      templates_ref:
        description: 'Branch/tag do repo de templates'
        required: false
        type: string
        default: 'main'
      project_name:
        description: 'Nome do projeto .csproj'
        required: false
        type: string
        default: ''
      dotnet_version:
        description: 'Vers√£o do .NET SDK'
        required: false
        type: string
        default: '8.0'
      working_directory:
        description: 'Diret√≥rio do c√≥digo fonte'
        required: false
        type: string
        default: 'src'
      dockerfile_path:
        description: 'Caminho do Dockerfile'
        required: false
        type: string
        default: ''
      aws_region:
        description: 'Regi√£o AWS'
        required: false
        type: string
        default: 'us-east-1'
      ecs_cluster:
        description: 'Nome do cluster ECS'
        required: false
        type: string
        default: ''
      ecs_task_execution_role_arn:
        description: 'ARN da role de execu√ß√£o da task'
        required: false
        type: string
        default: ''
      ecs_task_role_arn:
        description: 'ARN da role da task'
        required: false
        type: string
        default: ''
      task_cpu:
        description: 'CPU para Fargate (256, 512, 1024, 2048, 4096)'
        required: false
        type: string
        default: '256'
      task_memory:
        description: 'Mem√≥ria em MB para Fargate'
        required: false
        type: string
        default: '512'
      subnet_ids:
        description: 'IDs das subnets separados por v√≠rgula'
        required: false
        type: string
        default: ''
      security_group_ids:
        description: 'IDs dos security groups separados por v√≠rgula'
        required: false
        type: string
        default: ''
      assign_public_ip:
        description: 'Atribuir IP p√∫blico (ENABLED/DISABLED)'
        required: false
        type: string
        default: 'DISABLED'
      desired_count:
        description: 'N√∫mero desejado de tasks'
        required: false
        type: string
        default: '1'
      create_target_group_and_listener:
        description: 'Para API: obter ou criar target group e listener'
        required: false
        type: boolean
        default: false
      load_balancer_arn:
        description: 'ARN do ALB'
        required: false
        type: string
        default: ''
      load_balancer_name:
        description: 'Nome do ALB existente'
        required: false
        type: string
        default: ''
      listener_port:
        description: 'Porta do listener'
        required: false
        type: string
        default: '80'
      listener_protocol:
        description: 'Protocolo do listener (HTTP ou HTTPS)'
        required: false
        type: string
        default: 'HTTP'
      listener_certificate_arn:
        description: 'ARN do certificado ACM'
        required: false
        type: string
        default: ''
      target_group_name:
        description: 'Nome do target group'
        required: false
        type: string
        default: ''
      target_group_port:
        description: 'Porta do target group'
        required: false
        type: string
        default: '80'
      target_group_protocol:
        description: 'Protocolo do target group'
        required: false
        type: string
        default: 'HTTP'
      target_group_health_check_path:
        description: 'Caminho do health check'
        required: false
        type: string
        default: '/'
      target_group_health_check_protocol:
        description: 'Protocolo do health check'
        required: false
        type: string
        default: 'HTTP'
      target_group_deregistration_delay_seconds:
        description: 'Deregistration delay em segundos'
        required: false
        type: string
        default: '300'
      listener_rule_path_pattern:
        description: 'Path pattern para regra do listener'
        required: false
        type: string
        default: ''
      listener_rule_host_header:
        description: 'Host header para regra do listener'
        required: false
        type: string
        default: ''
      listener_rule_priority:
        description: 'Prioridade da regra do listener'
        required: false
        type: string
        default: ''
      container_name:
        description: 'Nome do container na task definition'
        required: false
        type: string
        default: 'app'
      container_port:
        description: 'Porta do container'
        required: false
        type: string
        default: '80'
      container_environment:
        description: 'JSON array de vari√°veis de ambiente'
        required: false
        type: string
        default: ''
      container_secrets:
        description: 'JSON array de secrets'
        required: false
        type: string
        default: ''
      runtime_cpu_architecture:
        description: 'CPU da plataforma (X86_64, ARM64)'
        required: false
        type: string
        default: ''
      runtime_os_family:
        description: 'OS da plataforma (LINUX, WINDOWS_SERVER_2019_CORE)'
        required: false
        type: string
        default: ''
      awslogs_mode:
        description: 'Modo awslogs (non-blocking ou blocking)'
        required: false
        type: string
        default: ''
      awslogs_create_group:
        description: 'Criar log group se n√£o existir'
        required: false
        type: string
        default: ''
      awslogs_max_buffer_size:
        description: 'Tamanho m√°ximo do buffer'
        required: false
        type: string
        default: ''
      port_mapping_app_protocol:
        description: 'appProtocol do portMapping'
        required: false
        type: string
        default: ''
      enable_zone_rebalancing:
        description: 'Ativar rebalanceamento de zonas'
        required: false
        type: boolean
        default: false
      health_check_grace_period_seconds:
        description: 'Per√≠odo de car√™ncia do health check'
        required: false
        type: string
        default: ''
      deployment_circuit_breaker_enable:
        description: 'Habilitar disjuntor de implanta√ß√£o'
        required: false
        type: boolean
        default: false
      deployment_circuit_breaker_rollback:
        description: 'Rollback autom√°tico quando disjuntor disparar'
        required: false
        type: boolean
        default: false
      capacity_provider_strategy:
        description: 'Estrat√©gia de capacity providers'
        required: false
        type: string
        default: ''
      platform_version:
        description: 'Vers√£o da plataforma Fargate'
        required: false
        type: string
        default: ''
      enable_execute_command:
        description: 'Ativar ECS Exec'
        required: false
        type: boolean
        default: false
      deployment_minimum_healthy_percent:
        description: 'M√≠nimo % de tarefas saud√°veis'
        required: false
        type: string
        default: ''
      deployment_maximum_percent:
        description: 'M√°ximo % de tarefas durante deploy'
        required: false
        type: string
        default: ''
      enable_health_check:
        description: 'Executar health check HTTP p√≥s-deploy'
        required: false
        type: boolean
        default: false
      health_check_url:
        description: 'URL do health check'
        required: false
        type: string
        default: ''
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      ECS_CLUSTER:
        required: false
      ECS_TASK_EXECUTION_ROLE_ARN:
        required: false
      REPO_ACCESS_TOKEN:
        required: false
    outputs:
      image_digest:
        description: 'Digest da imagem no ECR'
        value: ${{ jobs.pipeline.outputs.image_digest }}
      image_tag:
        description: 'Tag da imagem (SHA)'
        value: ${{ jobs.pipeline.outputs.image_tag }}
      deployed_service_arn:
        description: 'ARN do service ECS'
        value: ${{ jobs.pipeline.outputs.deployed_service_arn }}
      task_definition_arn:
        description: 'ARN da task definition registrada'
        value: ${{ jobs.pipeline.outputs.task_definition_arn }}

jobs:
  pipeline:
    name: Build, Test, Docker, ECR, ECS
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      image_digest: ${{ steps.ecr-push.outputs.image_digest }}
      image_tag: ${{ steps.ecr-push.outputs.image_tag }}
      deployed_service_arn: ${{ steps.ecs-finalize.outputs.service_arn }}
      task_definition_arn: ${{ steps.task-def.outputs.task_definition_arn }}

    steps:
      - name: Validar ambiente e service
        id: validate
        run: |
          ENV="${{ inputs.environment }}"
          case "$ENV" in dev|qa|sbx|prd) echo "‚úÖ Ambiente: $ENV" ;; *) echo "‚ùå Ambiente inv√°lido"; exit 1 ;; esac
          [ -z "${{ inputs.ecs_service }}" ] && echo "‚ùå ecs_service obrigat√≥rio" && exit 1
          [ -z "${{ inputs.ecr_repo }}" ] && echo "‚ùå ecr_repo obrigat√≥rio" && exit 1
          echo "ecr_repository=${{ inputs.ecr_repo }}" >> $GITHUB_OUTPUT
          echo "ecs_service=${{ inputs.ecs_service }}" >> $GITHUB_OUTPUT

      - name: Checkout aplica√ß√£o
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ inputs.dotnet_version }}

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles(format('{0}/**/*.csproj', inputs.working_directory)) }}

      - name: Restore e Test
        working-directory: ${{ inputs.working_directory }}
        run: |
          dotnet restore
          dotnet test --no-restore --verbosity normal

      - name: Checkout templates
        if: inputs.use_default_dockerfile && inputs.templates_repo != ''
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.templates_repo }}
          ref: ${{ inputs.templates_ref }}
          path: .ci-templates
          token: ${{ secrets.REPO_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Definir Dockerfile
        id: dockerfile-path
        run: |
          if [ "${{ inputs.use_default_dockerfile }}" = "true" ] && [ -n "${{ inputs.templates_repo }}" ]; then
            echo "dockerfile=.ci-templates/build/Dockerfile.${{ inputs.service_type }}" >> $GITHUB_OUTPUT
          else
            DF="${{ inputs.dockerfile_path }}"
            [ -z "$DF" ] && DF="Dockerfile.${{ inputs.service_type }}"
            echo "dockerfile=${DF}" >> $GITHUB_OUTPUT
          fi

      - name: Build Docker
        run: |
          ARGS=""
          [ -n "${{ inputs.project_name }}" ] && ARGS="--build-arg PROJECT_NAME=${{ inputs.project_name }}"
          docker build -t ci-build -f ${{ steps.dockerfile-path.outputs.dockerfile }} $ARGS .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Push to ECR
        id: ecr-push
        env:
          REGISTRY: ${{ inputs.ecr_registry || steps.login-ecr.outputs.registry }}
          ECR_REPO: ${{ steps.validate.outputs.ecr_repository }}
        run: |
          [ -z "$REGISTRY" ] && echo "‚ùå Registry vazio" && exit 1
          IMG="${REGISTRY}/${ECR_REPO}"
          docker tag ci-build "${IMG}:${{ github.sha }}"
          docker push "${IMG}:${{ github.sha }}"
          docker tag ci-build "${IMG}:${{ github.ref_name }}"
          docker push "${IMG}:${{ github.ref_name }}"
          TS="$(date -u +%Y%m%d-%H%M%S)"
          docker tag ci-build "${IMG}:${TS}"
          docker push "${IMG}:${TS}"
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ci-build | cut -d'@' -f2)
          echo "image_digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "‚úÖ Pushed ${IMG}:${{ github.sha }}"

      # ========== TASK DEFINITION ==========
      - name: Registrar Task Definition
        id: task-def
        env:
          CLUSTER: ${{ inputs.ecs_cluster || secrets.ECS_CLUSTER }}
          SERVICE: ${{ steps.validate.outputs.ecs_service }}
          REGISTRY: ${{ steps.ecr-push.outputs.registry }}
          ECR_REPO: ${{ steps.validate.outputs.ecr_repository }}
          IMAGE_TAG: ${{ steps.ecr-push.outputs.image_tag }}
          TASK_EXEC_ROLE: ${{ inputs.ecs_task_execution_role_arn || secrets.ECS_TASK_EXECUTION_ROLE_ARN }}
          TASK_ROLE: ${{ inputs.ecs_task_role_arn }}
          CONTAINER_NAME: ${{ inputs.container_name || 'app' }}
          CONTAINER_PORT: ${{ inputs.container_port || '80' }}
          AWS_REGION: ${{ inputs.aws_region }}
          TASK_CPU: ${{ inputs.task_cpu || '256' }}
          TASK_MEMORY: ${{ inputs.task_memory || '512' }}
          CONTAINER_ENVIRONMENT: ${{ inputs.container_environment }}
          CONTAINER_SECRETS: ${{ inputs.container_secrets }}
          RUNTIME_CPU: ${{ inputs.runtime_cpu_architecture }}
          RUNTIME_OS: ${{ inputs.runtime_os_family }}
          AWSLOGS_MODE: ${{ inputs.awslogs_mode }}
          AWSLOGS_CREATE_GROUP: ${{ inputs.awslogs_create_group }}
          AWSLOGS_MAX_BUFFER: ${{ inputs.awslogs_max_buffer_size }}
          PORT_APP_PROTOCOL: ${{ inputs.port_mapping_app_protocol }}
        run: |
          set -e
          FULL_IMAGE="${REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"
          echo "üñºÔ∏è Imagem: $FULL_IMAGE"
          
          EXISTING=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query 'services[?status==`ACTIVE`]' --output json)
          SERVICE_EXISTS=$(echo "$EXISTING" | jq 'length > 0')
          echo "service_exists=${SERVICE_EXISTS}" >> $GITHUB_OUTPUT
          
          if [ "$SERVICE_EXISTS" = "true" ]; then
            echo "üîÑ Service existe: reutilizando task definition..."
            CURRENT_TASK_ARN=$(echo "$EXISTING" | jq -r '.[0].taskDefinition')
            TASK_DEF_JSON=$(aws ecs describe-task-definition --task-definition "$CURRENT_TASK_ARN" --query 'taskDefinition' --output json)
            TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq 'del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities,.registeredAt,.registeredBy)')
            TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --arg img "$FULL_IMAGE" '.containerDefinitions[0].image = $img')
            if [ -n "$CONTAINER_ENVIRONMENT" ] && [ "$CONTAINER_ENVIRONMENT" != "[]" ]; then
              echo "$CONTAINER_ENVIRONMENT" | jq -e . >/dev/null 2>&1 && \
              TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --argjson env "$CONTAINER_ENVIRONMENT" '.containerDefinitions[0].environment = $env')
            fi
          else
            echo "üÜï Service n√£o existe: criando task definition do zero..."
            [ -z "$TASK_EXEC_ROLE" ] && echo "‚ùå Role obrigat√≥ria" && exit 1
            
            PORT_NUM=$(echo "$CONTAINER_PORT" | grep -E '^[0-9]+$' || echo "80")
            LOG_GROUP="/ecs/${SERVICE}"
            
            # Port mapping
            PORT_MAPPING=$(jq -n --arg name "${CONTAINER_NAME}-${PORT_NUM}-tcp" --argjson port "$PORT_NUM" \
              '{name:$name,containerPort:$port,hostPort:$port,protocol:"tcp"}')
            [ -n "$PORT_APP_PROTOCOL" ] && PORT_MAPPING=$(echo "$PORT_MAPPING" | jq --arg p "$PORT_APP_PROTOCOL" '.+{appProtocol:$p}')
            
            # Log opts
            LOG_OPTS=$(jq -n --arg lg "$LOG_GROUP" --arg r "$AWS_REGION" '{"awslogs-group":$lg,"awslogs-region":$r,"awslogs-stream-prefix":"ecs"}')
            [ -n "$AWSLOGS_MODE" ] && LOG_OPTS=$(echo "$LOG_OPTS" | jq --arg m "$AWSLOGS_MODE" '.+{mode:$m}')
            [ -n "$AWSLOGS_CREATE_GROUP" ] && LOG_OPTS=$(echo "$LOG_OPTS" | jq --arg c "$AWSLOGS_CREATE_GROUP" '.+{"awslogs-create-group":$c}')
            [ -n "$AWSLOGS_MAX_BUFFER" ] && LOG_OPTS=$(echo "$LOG_OPTS" | jq --arg b "$AWSLOGS_MAX_BUFFER" '.+{"max-buffer-size":$b}')
            
            # Container def
            CONTAINER_DEF=$(jq -n --arg n "$CONTAINER_NAME" --arg img "$FULL_IMAGE" --argjson pm "$PORT_MAPPING" --argjson lo "$LOG_OPTS" \
              '{name:$n,image:$img,portMappings:[$pm],logConfiguration:{logDriver:"awslogs",options:$lo},essential:true}')
            [ -n "$CONTAINER_ENVIRONMENT" ] && [ "$CONTAINER_ENVIRONMENT" != "[]" ] && \
              echo "$CONTAINER_ENVIRONMENT" | jq -e . >/dev/null 2>&1 && \
              CONTAINER_DEF=$(echo "$CONTAINER_DEF" | jq --argjson e "$CONTAINER_ENVIRONMENT" '.+{environment:$e}')
            [ -n "$CONTAINER_SECRETS" ] && [ "$CONTAINER_SECRETS" != "[]" ] && \
              echo "$CONTAINER_SECRETS" | jq -e . >/dev/null 2>&1 && \
              CONTAINER_DEF=$(echo "$CONTAINER_DEF" | jq --argjson s "$CONTAINER_SECRETS" '.+{secrets:$s}')
            
            # Task def
            TASK_DEF_JSON=$(jq -n --arg f "$SERVICE" --arg er "$TASK_EXEC_ROLE" --arg cpu "$TASK_CPU" --arg mem "$TASK_MEMORY" --argjson c "$CONTAINER_DEF" \
              '{family:$f,networkMode:"awsvpc",requiresCompatibilities:["FARGATE"],cpu:$cpu,memory:$mem,executionRoleArn:$er,containerDefinitions:[$c]}')
            [ -n "$TASK_ROLE" ] && TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --arg tr "$TASK_ROLE" '.+{taskRoleArn:$tr}')
            
            # Runtime platform
            if [ -n "$RUNTIME_CPU" ] || [ -n "$RUNTIME_OS" ]; then
              RT=$(jq -n '{}')
              [ -n "$RUNTIME_CPU" ] && RT=$(echo "$RT" | jq --arg c "$RUNTIME_CPU" '.+{cpuArchitecture:$c}')
              [ -n "$RUNTIME_OS" ] && RT=$(echo "$RT" | jq --arg o "$RUNTIME_OS" '.+{operatingSystemFamily:$o}')
              TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --argjson rt "$RT" '.+{runtimePlatform:$rt}')
            fi
          fi
          
          # Register
          TASK_DEF_FILE=$(mktemp)
          echo "$TASK_DEF_JSON" > "$TASK_DEF_FILE"
          NEW_TASK_ARN=$(aws ecs register-task-definition --cli-input-json "file://${TASK_DEF_FILE}" --query 'taskDefinition.taskDefinitionArn' --output text)
          rm -f "$TASK_DEF_FILE"
          echo "task_definition_arn=${NEW_TASK_ARN}" >> $GITHUB_OUTPUT
          echo "‚úÖ Task definition: $NEW_TASK_ARN"

      # ========== TARGET GROUP (API only) ==========
      - name: Configurar Target Group
        id: target-group
        if: inputs.service_type == 'api' && inputs.create_target_group_and_listener
        env:
          SUBNET_IDS: ${{ inputs.subnet_ids }}
          TG_NAME: ${{ inputs.target_group_name }}
          TG_PORT: ${{ inputs.target_group_port }}
          TG_PROTOCOL: ${{ inputs.target_group_protocol }}
          TG_HEALTH_CHECK_PATH: ${{ inputs.target_group_health_check_path }}
          TG_HEALTH_CHECK_PROTOCOL: ${{ inputs.target_group_health_check_protocol }}
          TG_DEREGISTRATION_DELAY: ${{ inputs.target_group_deregistration_delay_seconds }}
          LOAD_BALANCER_ARN: ${{ inputs.load_balancer_arn }}
          LOAD_BALANCER_NAME: ${{ inputs.load_balancer_name }}
        run: |
          set -e
          [ -z "$TG_NAME" ] && echo "‚ùå target_group_name obrigat√≥rio para API" && exit 1
          
          # Resolver LB ARN
          LB_ARN="$LOAD_BALANCER_ARN"
          if [ -z "$LB_ARN" ] && [ -n "$LOAD_BALANCER_NAME" ]; then
            LB_ARN=$(aws elbv2 describe-load-balancers --names "$LOAD_BALANCER_NAME" --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || true)
            [ -z "$LB_ARN" ] || [ "$LB_ARN" = "None" ] && echo "‚ùå LB '$LOAD_BALANCER_NAME' n√£o encontrado" && exit 1
          fi
          [ -z "$LB_ARN" ] && echo "‚ùå Informe load_balancer_arn ou load_balancer_name" && exit 1
          echo "load_balancer_arn=${LB_ARN}" >> $GITHUB_OUTPUT
          
          # VPC
          FIRST_SUBNET=$(echo "$SUBNET_IDS" | cut -d',' -f1)
          VPC_ID=$(aws ec2 describe-subnets --subnet-ids "$FIRST_SUBNET" --query 'Subnets[0].VpcId' --output text)
          
          # TG existente?
          EXISTING_TG=$(aws elbv2 describe-target-groups --names "$TG_NAME" --query 'TargetGroups[0]' --output json 2>/dev/null || echo "null")
          if [ "$EXISTING_TG" != "null" ]; then
            TG_ARN=$(echo "$EXISTING_TG" | jq -r '.TargetGroupArn')
            echo "‚úÖ TG existente: $TG_ARN"
          else
            echo "üìù Criando TG: $TG_NAME"
            TG_ARN=$(aws elbv2 create-target-group \
              --name "$TG_NAME" --protocol "${TG_PROTOCOL:-HTTP}" --port "${TG_PORT:-80}" \
              --vpc-id "$VPC_ID" --target-type ip \
              --health-check-path "${TG_HEALTH_CHECK_PATH:-/}" --health-check-protocol "${TG_HEALTH_CHECK_PROTOCOL:-HTTP}" \
              --query 'TargetGroups[0].TargetGroupArn' --output text)
            echo "‚úÖ TG criado: $TG_ARN"
            [ -n "$TG_DEREGISTRATION_DELAY" ] && [ "$TG_DEREGISTRATION_DELAY" != "300" ] && \
              aws elbv2 modify-target-group-attributes --target-group-arn "$TG_ARN" \
                --attributes "Key=deregistration_delay.timeout_seconds,Value=$TG_DEREGISTRATION_DELAY"
          fi
          echo "target_group_arn=${TG_ARN}" >> $GITHUB_OUTPUT

      # ========== LISTENER RULE (API only) ==========
      - name: Configurar Listener Rule
        id: listener-rule
        if: inputs.service_type == 'api' && inputs.create_target_group_and_listener
        env:
          SERVICE: ${{ steps.validate.outputs.ecs_service }}
          LOAD_BALANCER_ARN: ${{ steps.target-group.outputs.load_balancer_arn }}
          TARGET_GROUP_ARN: ${{ steps.target-group.outputs.target_group_arn }}
          LISTENER_PORT: ${{ inputs.listener_port }}
          LISTENER_RULE_PATH: ${{ inputs.listener_rule_path_pattern }}
          LISTENER_RULE_HOST: ${{ inputs.listener_rule_host_header }}
          LISTENER_RULE_PRIORITY: ${{ inputs.listener_rule_priority }}
        run: |
          set -e
          PORT="${LISTENER_PORT:-80}"
          
          # Listener existente
          LISTENER_JSON=$(aws elbv2 describe-listeners --load-balancer-arn "$LOAD_BALANCER_ARN" \
            --query "Listeners[?Port==\`$PORT\`]" --output json | jq '.[0]')
          [ "$LISTENER_JSON" = "null" ] && echo "‚ùå Listener porta $PORT n√£o existe" && exit 1
          LISTENER_ARN=$(echo "$LISTENER_JSON" | jq -r '.ListenerArn')
          echo "‚úÖ Listener: $LISTENER_ARN"
          echo "listener_arn=${LISTENER_ARN}" >> $GITHUB_OUTPUT
          
          # Verificar regra existente
          RULES=$(aws elbv2 describe-rules --listener-arn "$LISTENER_ARN" --output json)
          TG_RULE=$(echo "$RULES" | jq -r --arg tg "$TARGET_GROUP_ARN" '.Rules[]|select(.Actions[]?.TargetGroupArn==$tg)|.RuleArn' | head -1)
          
          if [ -n "$TG_RULE" ]; then
            echo "‚úÖ TG j√° associado (regra: $TG_RULE)"
          else
            echo "üìù Criando regra no listener..."
            # Prioridade
            if [ -n "$LISTENER_RULE_PRIORITY" ]; then
              PRIORITY="$LISTENER_RULE_PRIORITY"
            else
              MAX_P=$(echo "$RULES" | jq '[.Rules[]|select(.Priority!="default")|.Priority|tonumber]|max // 0')
              PRIORITY=$((MAX_P + 1))
            fi
            
            # Condi√ß√µes
            COND_FILE=$(mktemp)
            if [ -n "$LISTENER_RULE_HOST" ] && [ -n "$LISTENER_RULE_PATH" ]; then
              jq -n --arg h "$LISTENER_RULE_HOST" --arg p "$LISTENER_RULE_PATH" \
                '[{Field:"host-header",HostHeaderConfig:{Values:[$h]}},{Field:"path-pattern",PathPatternConfig:{Values:[$p]}}]' > "$COND_FILE"
              DESC="Host:$LISTENER_RULE_HOST E Path:$LISTENER_RULE_PATH"
            elif [ -n "$LISTENER_RULE_HOST" ]; then
              jq -n --arg h "$LISTENER_RULE_HOST" '[{Field:"host-header",HostHeaderConfig:{Values:[$h]}}]' > "$COND_FILE"
              DESC="Host:$LISTENER_RULE_HOST"
            else
              PATH="${LISTENER_RULE_PATH:-/${SERVICE}*}"
              jq -n --arg p "$PATH" '[{Field:"path-pattern",PathPatternConfig:{Values:[$p]}}]' > "$COND_FILE"
              DESC="Path:$PATH"
            fi
            
            echo "   Prioridade: $PRIORITY | Condi√ß√£o: $DESC"
            RULE_ARN=$(aws elbv2 create-rule --listener-arn "$LISTENER_ARN" --priority "$PRIORITY" \
              --conditions "file://${COND_FILE}" --actions "Type=forward,TargetGroupArn=$TARGET_GROUP_ARN" \
              --query 'Rules[0].RuleArn' --output text)
            rm -f "$COND_FILE"
            echo "‚úÖ Regra criada: $RULE_ARN"
          fi

      # ========== CREATE/UPDATE SERVICE ==========
      - name: Deploy ECS Service
        id: ecs-deploy
        env:
          CLUSTER: ${{ inputs.ecs_cluster || secrets.ECS_CLUSTER }}
          SERVICE: ${{ steps.validate.outputs.ecs_service }}
          NEW_TASK_ARN: ${{ steps.task-def.outputs.task_definition_arn }}
          SERVICE_EXISTS: ${{ steps.task-def.outputs.service_exists }}
          SERVICE_TYPE: ${{ inputs.service_type }}
          TARGET_GROUP_ARN: ${{ steps.target-group.outputs.target_group_arn }}
          CONTAINER_NAME: ${{ inputs.container_name || 'app' }}
          CONTAINER_PORT: ${{ inputs.container_port || '80' }}
          SUBNET_IDS: ${{ inputs.subnet_ids }}
          SECURITY_GROUPS: ${{ inputs.security_group_ids }}
          DESIRED_COUNT: ${{ inputs.desired_count || '1' }}
          ASSIGN_PUBLIC_IP: ${{ inputs.assign_public_ip || 'DISABLED' }}
          ENABLE_ZONE_REBALANCING: ${{ inputs.enable_zone_rebalancing }}
          HEALTH_GRACE_PERIOD: ${{ inputs.health_check_grace_period_seconds }}
          CIRCUIT_BREAKER_ENABLE: ${{ inputs.deployment_circuit_breaker_enable }}
          CIRCUIT_BREAKER_ROLLBACK: ${{ inputs.deployment_circuit_breaker_rollback }}
          CAPACITY_PROVIDER_STRATEGY: ${{ inputs.capacity_provider_strategy }}
          PLATFORM_VERSION: ${{ inputs.platform_version }}
          ENABLE_EXEC_COMMAND: ${{ inputs.enable_execute_command }}
          DEPLOY_MIN_HEALTHY: ${{ inputs.deployment_minimum_healthy_percent }}
          DEPLOY_MAX_PERCENT: ${{ inputs.deployment_maximum_percent }}
        run: |
          set -e
          PORT_NUM=$(echo "$CONTAINER_PORT" | grep -E '^[0-9]+$' || echo "80")
          
          # Deployment config
          DEPLOY_CFG=""
          if [ "$CIRCUIT_BREAKER_ENABLE" = "true" ] || [ -n "$DEPLOY_MIN_HEALTHY" ] || [ -n "$DEPLOY_MAX_PERCENT" ]; then
            CFG_FILE=$(mktemp)
            CFG=$(jq -n '{}')
            if [ "$CIRCUIT_BREAKER_ENABLE" = "true" ]; then
              RB="false"; [ "$CIRCUIT_BREAKER_ROLLBACK" = "true" ] && RB="true"
              CFG=$(echo "$CFG" | jq --argjson rb "$RB" '.+{deploymentCircuitBreaker:{enable:true,rollback:$rb}}')
            fi
            [ -n "$DEPLOY_MIN_HEALTHY" ] && CFG=$(echo "$CFG" | jq --argjson m "$DEPLOY_MIN_HEALTHY" '.+{minimumHealthyPercent:$m}')
            [ -n "$DEPLOY_MAX_PERCENT" ] && CFG=$(echo "$CFG" | jq --argjson m "$DEPLOY_MAX_PERCENT" '.+{maximumPercent:$m}')
            echo "$CFG" > "$CFG_FILE"
            DEPLOY_CFG="--deployment-configuration file://${CFG_FILE}"
          fi
          
          # Capacity provider
          LAUNCH=""
          if [ -n "$CAPACITY_PROVIDER_STRATEGY" ]; then
            CP_FILE=$(mktemp)
            echo "[" > "$CP_FILE"
            FIRST=true
            IFS=',' read -ra PARTS <<< "$CAPACITY_PROVIDER_STRATEGY"
            for part in "${PARTS[@]}"; do
              prov=$(echo "$part"|cut -d':' -f1); base=$(echo "$part"|cut -d':' -f2); weight=$(echo "$part"|cut -d':' -f3)
              [ -z "$base" ] && base=0; [ -z "$weight" ] && weight=1
              [ "$FIRST" = true ] && FIRST=false || echo "," >> "$CP_FILE"
              jq -n --arg p "$prov" --argjson w "$weight" --argjson b "$base" '{capacityProvider:$p,weight:$w,base:$b}' >> "$CP_FILE"
            done
            echo "]" >> "$CP_FILE"
            LAUNCH="--capacity-provider-strategy file://${CP_FILE}"
          else
            LAUNCH="--launch-type FARGATE"
          fi
          
          if [ "$SERVICE_EXISTS" = "true" ]; then
            echo "üîÑ Atualizando service..."
            CMD="aws ecs update-service --cluster $CLUSTER --service $SERVICE --task-definition $NEW_TASK_ARN --force-new-deployment"
            [ "$ENABLE_ZONE_REBALANCING" = "true" ] && CMD="$CMD --enable-zone-rebalancing"
            [ -n "$HEALTH_GRACE_PERIOD" ] && CMD="$CMD --health-check-grace-period-seconds $HEALTH_GRACE_PERIOD"
            [ -n "$PLATFORM_VERSION" ] && CMD="$CMD --platform-version $PLATFORM_VERSION"
            [ "$ENABLE_EXEC_COMMAND" = "true" ] && CMD="$CMD --enable-execute-command"
            [ -n "$DEPLOY_CFG" ] && CMD="$CMD $DEPLOY_CFG"
            $CMD --query 'service.serviceArn' --output text
          else
            echo "üÜï Criando service..."
            [ -z "$SUBNET_IDS" ] || [ -z "$SECURITY_GROUPS" ] && echo "‚ùå subnet_ids e security_group_ids obrigat√≥rios" && exit 1
            
            SUBNETS=$(echo "$SUBNET_IDS" | tr ',' '\n' | jq -R . | jq -s .)
            SGS=$(echo "$SECURITY_GROUPS" | tr ',' '\n' | jq -R . | jq -s .)
            NET_FILE=$(mktemp)
            jq -n --argjson s "$SUBNETS" --argjson g "$SGS" --arg a "$ASSIGN_PUBLIC_IP" \
              '{awsvpcConfiguration:{subnets:$s,securityGroups:$g,assignPublicIp:$a}}' > "$NET_FILE"
            
            if [ "$SERVICE_TYPE" = "api" ] && [ -n "$TARGET_GROUP_ARN" ]; then
              LB_FILE=$(mktemp)
              jq -n --arg tg "$TARGET_GROUP_ARN" --arg cn "$CONTAINER_NAME" --argjson cp "$PORT_NUM" \
                '[{targetGroupArn:$tg,containerName:$cn,containerPort:$cp}]' > "$LB_FILE"
              aws ecs create-service --cluster "$CLUSTER" --service-name "$SERVICE" --task-definition "$NEW_TASK_ARN" \
                --desired-count "${DESIRED_COUNT:-1}" --network-configuration "file://${NET_FILE}" \
                --load-balancers "file://${LB_FILE}" $LAUNCH --query 'service.serviceArn' --output text
              rm -f "$LB_FILE"
            else
              aws ecs create-service --cluster "$CLUSTER" --service-name "$SERVICE" --task-definition "$NEW_TASK_ARN" \
                --desired-count "${DESIRED_COUNT:-1}" --network-configuration "file://${NET_FILE}" \
                $LAUNCH --query 'service.serviceArn' --output text
            fi
            rm -f "$NET_FILE"
          fi
          
          # Cleanup temp files
          [ -n "$CFG_FILE" ] && rm -f "$CFG_FILE" 2>/dev/null || true
          [ -n "$CP_FILE" ] && rm -f "$CP_FILE" 2>/dev/null || true

      - name: Aguardar estabiliza√ß√£o
        id: ecs-finalize
        env:
          CLUSTER: ${{ inputs.ecs_cluster || secrets.ECS_CLUSTER }}
          SERVICE: ${{ steps.validate.outputs.ecs_service }}
        run: |
          echo "‚è≥ Aguardando deployment estabilizar..."
          aws ecs wait services-stable --cluster "$CLUSTER" --services "$SERVICE"
          SERVICE_ARN=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query 'services[0].serviceArn' --output text)
          echo "service_arn=${SERVICE_ARN}" >> $GITHUB_OUTPUT
          echo "‚úÖ Deployment conclu√≠do: $SERVICE_ARN"

      - name: Gerar deploy metadata
        if: success()
        run: |
          mkdir -p .deploys
          cat << EOF > .deploys/deploy.json
          {
            "environment": "${{ inputs.environment }}",
            "ecs_service": "${{ inputs.ecs_service }}",
            "image_digest": "${{ steps.ecr-push.outputs.image_digest }}",
            "image_tag": "${{ steps.ecr-push.outputs.image_tag }}",
            "task_definition_arn": "${{ steps.task-def.outputs.task_definition_arn }}",
            "service_arn": "${{ steps.ecs-finalize.outputs.service_arn }}",
            "commit_sha": "${{ github.sha }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "run_id": "${{ github.run_id }}"
          }
          EOF

      - name: Upload deploy metadata
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: deploy-${{ inputs.environment }}-${{ inputs.ecs_service }}-${{ github.run_id }}
          path: .deploys

      - name: Health check
        if: inputs.enable_health_check && inputs.health_check_url != ''
        run: |
          URL="${{ inputs.health_check_url }}"
          for i in $(seq 1 12); do
            curl -sf "$URL" > /dev/null && echo "‚úÖ Health check OK" && exit 0
            echo "Tentativa $i/12 falhou; aguardando 10s..."
            sleep 10
          done
          echo "‚ùå Health check falhou" && exit 1
